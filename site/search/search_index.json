{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"appendices/code-samples/","title":"Appendices: Code Samples","text":"<p>This appendix provides a collection of code snippets used throughout the project for CSI collection, processing, and visualization.</p>"},{"location":"appendices/code-samples/#1-serial-logging-with-timestamps","title":"1. Serial Logging with Timestamps","text":"<p>Add real-time timestamps to CSI data from ESP32 UART stream:</p> <pre><code>import time\nimport serial\n\nser = serial.Serial('/dev/ttyUSB0', 921600)\n\nwith open('csi_output_timed.csv', 'w') as out:\n    while True:\n        line = ser.readline().decode(errors='ignore').strip()\n        if 'CSI_DATA' in line:\n            timestamp = int(time.time() * 1000)\n            out.write(f\"{timestamp}, {line}\\n\")\n</code></pre>"},{"location":"appendices/code-samples/#2-amplitude-and-phase-calculation","title":"2. Amplitude and Phase Calculation","text":"<p>Convert raw I/Q samples to amplitude and phase:</p> <pre><code>import numpy as np\n\n# Example raw CSI line (interleaved I/Q pairs)\ncsi_raw = [8, -4, 7, 1, 9, 3, 10, 5]  # I1,Q1, I2,Q2, ...\ni_vals = csi_raw[0::2]\nq_vals = csi_raw[1::2]\n\namplitude = np.sqrt(np.square(i_vals) + np.square(q_vals))\nphase = np.arctan2(q_vals, i_vals)\n</code></pre>"},{"location":"appendices/code-samples/#3-phase-unwrapping-and-linear-detrending","title":"3. Phase Unwrapping and Linear Detrending","text":"<pre><code>from scipy.stats import linregress\n\n# Unwrap phase\ndelta = np.diff(phase)\ndelta[delta &gt; np.pi] -= 2 * np.pi\ndelta[delta &lt; -np.pi] += 2 * np.pi\nunwrapped = np.cumsum(np.insert(delta, 0, phase[0]))\n\n# Remove linear bias\nx = np.arange(len(unwrapped))\nslope, intercept, _, _, _ = linregress(x, unwrapped)\ndetrended = unwrapped - (slope * x + intercept)\n</code></pre>"},{"location":"appendices/code-samples/#4-plotting-amplitude","title":"4. Plotting Amplitude","text":"<pre><code>import matplotlib.pyplot as plt\n\nplt.plot(amplitude)\nplt.title(\"CSI Amplitude\")\nplt.xlabel(\"Subcarrier Index\")\nplt.ylabel(\"Amplitude\")\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"appendices/code-samples/#5-reference-csi-preprocessing-script","title":"5. Reference \u2013 CSI Preprocessing Script","text":"<p>The following operations are implemented in the custom CSI preprocessing script developed by RayIoT Solutions:</p> <ul> <li>Captures CSI data from standard input</li> <li>Extracts I/Q values from CSI frames</li> <li>Converts I/Q into amplitude and phase</li> <li>Applies phase unwrapping to remove discontinuities</li> <li>Applies linear detrending to eliminate hardware bias</li> <li>Adds timestamp in milliseconds to each CSI log entry</li> </ul>"},{"location":"appendices/code-samples/#file-phase_wrapped_filter_linear_fitting_v01_originalpy","title":"File: <code>phase_wrapped_filter_linear_fitting_v0.1_original.py</code>","text":"<pre><code># Extract real and imaginary parts\nfor i in range(len(csi_raw)):\n    if i % 2 == 0:\n        imaginary.append(csi_raw[i])\n    else:\n        real.append(csi_raw[i])\n\n# Calculate amplitude and phase\nfor i in range(frame_len):\n    amplitudes.append(sqrt(imaginary[i] ** 2 + real[i] ** 2))\n    phases.append(atan2(imaginary[i], real[i]))\n\n# Phase unwrapping loop\nfor i in range(frame_len - 1):\n    phases[i + 1] = unwrap_phase(phases[i], phases[i + 1])\n\n# Apply linear fit to sanitize unwrapped phase\nphase_filter_linear_fit(phases)\n\n# Append timestamp and print\nprint(f\"{formatted_time},{rssi}\")\n</code></pre>"},{"location":"appendices/code-samples/#summary","title":"Summary","text":"<p>These code samples represent core utilities used for working with CSI data from ESP32. Each can be adapted and extended for custom use cases like real-time analysis or batch training pipelines.</p>"},{"location":"appendices/datasets/","title":"Appendices: Dataset Samples","text":"<p>This appendix provides example entries and file structures for raw and preprocessed CSI datasets used in this project. These samples help users understand the formatting, field types, and structure required for analysis, visualization, and machine learning.</p>"},{"location":"appendices/datasets/#1-raw-csi-log-sample","title":"1. Raw CSI Log Sample","text":"<p>Captured using the ESP32 UART stream after enabling CSI in the firmware. This includes all metadata fields and raw I/Q pairs.</p> <pre><code>CSI_DATA,active_sta,84:f3:eb:12:34:56,-47,26,1,0,1,1,0,0,0,0,1,-95,3,1,0,123456789,0,128,1,1,1685735234576,114,[8 -4 7 1 9 3 10 5 13 6 16 6 17 3 15 1 12 -2 10 -3 ...]\n</code></pre>"},{"location":"appendices/datasets/#2-timestamped-csi-csv-sample","title":"2. Timestamped CSI CSV Sample","text":"<p>Captured using a Python wrapper that prepends UNIX timestamps to each CSI frame during real-time collection.</p> <pre><code>1685735234576,CSI_DATA,active_sta,84:f3:eb:12:34:56,-47,26,1,0,1,1,0,0,0,0,1,-95,3,1,0,123456789,0,128,1,1,1685735234576,114,[8 -4 7 1 9 3 10 5 13 6 16 6 17 3 15 1 12 -2 10 -3 ...]\n</code></pre>"},{"location":"appendices/datasets/#3-structured-iq-csv-format","title":"3. Structured I/Q CSV Format","text":"<p>Converted using a script to expand I/Q pairs into tabular format with each subcarrier's I and Q values as separate fields.</p> <pre><code>Timestamp,RSSI,Sub1_I,Sub1_Q,Sub2_I,Sub2_Q,...,Sub52_I,Sub52_Q\n1685735234576,-47,8,-4,7,1,9,3,10,5,...,10,-3\n</code></pre>"},{"location":"appendices/datasets/#4-amplitude-and-phase-csv-format","title":"4. Amplitude and Phase CSV Format","text":"<p>Derived from I/Q using amplitude = sqrt(I\u00b2 + Q\u00b2) and phase = atan2(Q, I) with unwrapping and linear fitting.</p> <pre><code>Timestamp,RSSI,Sub1_Amp,Sub1_Phase,Sub2_Amp,Sub2_Phase,...,Sub52_Amp,Sub52_Phase\n1685735234576,-47,8.9,2.36,7.2,1.83,...,10.1,-0.54\n</code></pre>"},{"location":"appendices/datasets/#5-downloadable-format-suggestions","title":"5. Downloadable Format Suggestions","text":"<ul> <li>Save raw <code>.csv</code> logs for reproducibility</li> <li>Compress datasets by session: <code>csi_data_session1_2025-06-25.zip</code></li> <li>Add metadata in <code>.txt</code> format: TX/RX position, room dimensions, environment, label (e.g., LoS/NLoS, breathing, motion)</li> <li>Store in <code>data-files/</code> directory for easy reference via MkDocs:</li> </ul> <p>Download Sample Output: sample-1.csv</p>"},{"location":"appendices/datasets/#summary","title":"Summary","text":"<p>These dataset formats represent the CSI data processing pipeline\u2014from raw UART logs to structured, timestamped, and filtered datasets. Standardizing these formats ensures consistent preprocessing, interpretability, and reproducibility across experiments.</p>"},{"location":"appendices/hardware-specs/","title":"Appendices: Hardware Specifications","text":"<p>This appendix lists the hardware specifications of the ESP32 boards and related components used in CSI data collection and experimentation.</p>"},{"location":"appendices/hardware-specs/#1-esp32-development-board","title":"1. ESP32 Development Board","text":""},{"location":"appendices/hardware-specs/#model-used","title":"Model Used","text":"<ul> <li>ESP32-WROOM-32 DevKit V1</li> </ul>"},{"location":"appendices/hardware-specs/#key-features","title":"Key Features","text":"Specification Value SoC ESP32-D0WDQ6 CPU Cores Dual-core Tensilica Xtensa LX6 Clock Speed Up to 240 MHz RAM 520 KB SRAM Flash Memory 4 MB (varies by board) Wi-Fi 802.11 b/g/n/e/i Bluetooth v4.2 BR/EDR and BLE UART 3 UART interfaces Operating Voltage 3.3 V USB to Serial Chip CP2102 or CH340"},{"location":"appendices/hardware-specs/#notes","title":"Notes","text":"<ul> <li>Ensure the board supports UART at \u2265 921600 baud for stable CSI output</li> <li>Most DevKit V1 boards come with CP2102 serial chip, which is reliable</li> </ul>"},{"location":"appendices/hardware-specs/#2-optional-components","title":"2. Optional Components","text":"Component Purpose Micro-USB Cable For power and serial interface SD Card Module Local CSI data logging (if used) Tripod Stand For stable sensor placement Breadboard &amp; Wires For prototyping if required"},{"location":"appendices/hardware-specs/#3-photos","title":"3. Photos","text":"<ul> <li> <p>ESP32-WROOM DevKit (Top View) </p> </li> <li> <p>Complete CSI Logging Setup </p> </li> </ul>"},{"location":"appendices/hardware-specs/#summary","title":"Summary","text":"<p>Refer to the Hardware Requirements section for the initial setup, procurement checklist, and environment considerations. This appendix provides deeper technical specifications to complement that setup.</p> <p>Understanding the ESP32 hardware specifications is essential to ensure proper configuration, stable UART communication, and reliable CSI data collection. Consistent and known hardware also ensures repeatability across experiments.</p>"},{"location":"applications/estimate-brpm/","title":"Applications: Estimation of Breathing Rate (BrPM)","text":"<p>Breathing rate estimation using CSI is a powerful, non-contact method for monitoring human respiration in real-time. The small, periodic movements of the chest during inhalation and exhalation induce micro-level changes in CSI phase and amplitude.</p>"},{"location":"applications/estimate-brpm/#1-principle","title":"1. Principle","text":"<p>Breathing causes periodic variations in signal reflections due to the slight movement of the chest wall. These changes primarily manifest as:</p> <ul> <li>Low-frequency oscillations in unwrapped phase</li> <li>Subtle amplitude shifts in static environments</li> </ul> <p>The frequency of these oscillations can be mapped directly to breaths per minute (BrPM).</p>"},{"location":"applications/estimate-brpm/#2-experimental-setup","title":"2. Experimental Setup","text":"<ul> <li>Environment: Quiet, temperature-stable room</li> <li>Person State: Sitting still, breathing normally</li> <li>Distance: TX-RX gap ~1.5 m</li> <li>ESP32 Modes:</li> <li>TX in <code>active_sta</code></li> <li>RX in <code>passive</code> or <code>active_ap</code></li> <li>Data Type: Unwrapped and detrended phase across selected subcarriers</li> </ul>"},{"location":"applications/estimate-brpm/#3-signal-processing-steps","title":"3. Signal Processing Steps","text":"<ol> <li>Capture and unwrap phase using <code>atan2(Q, I)</code> and <code>numpy.unwrap</code></li> <li>Detrend phase using linear fitting (to remove DC bias)</li> <li>Apply a band-pass filter (~0.1\u20130.5 Hz)</li> <li>Perform Fast Fourier Transform (FFT) or peak counting over sliding windows</li> <li>Estimate BrPM using:</li> </ol> <pre><code>brpm = peak_count * (60 / window_duration_in_seconds)\n</code></pre>"},{"location":"applications/estimate-brpm/#4-sample-visualization","title":"4. Sample Visualization","text":""},{"location":"applications/estimate-brpm/#example-output","title":"Example Output:","text":""},{"location":"applications/estimate-brpm/#time-window-start-2024-06-01-101500-detected-peaks-6-window-duration-30-seconds-estimated-brpm-12","title":"<pre><code>Time Window Start: 2024-06-01 10:15:00\nDetected Peaks: 6\nWindow Duration: 30 seconds\nEstimated BrPM: 12\n</code></pre>","text":""},{"location":"applications/estimate-brpm/#5-challenges-and-notes","title":"5. Challenges and Notes","text":"<ul> <li>Ensure minimal movement for clean respiration signal</li> <li>Signal may vary significantly by subcarrier; select the most stable one</li> <li>Ambient air flow, talking, or shifting posture can distort the signal</li> </ul>"},{"location":"applications/estimate-brpm/#summary","title":"Summary","text":"<p>By processing low-frequency oscillations in CSI phase data, we can estimate breathing rate (BrPM) reliably in static conditions. This technique is highly applicable in health monitoring systems for infants, patients, or elderly individuals without requiring contact-based sensors.</p>"},{"location":"applications/human-detection/","title":"Applications: Human Presence Detection","text":"<p>Human presence detection is one of the most fundamental and practical applications of CSI-based sensing. By monitoring small variations in the wireless channel, it is possible to determine whether a person is present in a room without using cameras or wearable devices.</p>"},{"location":"applications/human-detection/#1-concept","title":"1. Concept","text":"<p>When a human body enters a static wireless environment, it causes changes in signal reflection, diffraction, and absorption. These changes slightly distort the CSI amplitude and phase over time, even when the person is not moving.</p> <p>This disturbance can be monitored using: - Variations in CSI amplitude - Fluctuations in phase (especially if phase has been unwrapped) - Short-term vs. long-term signal stability</p>"},{"location":"applications/human-detection/#2-experimental-setup","title":"2. Experimental Setup","text":"<ul> <li>Environment: 4 m \u00d7 4 m office room, minimal motion, closed doors</li> <li>ESP32 Roles:</li> <li>TX: Transmitting packets (<code>active_sta</code> mode)</li> <li>RX: Receiving and logging CSI (<code>passive</code> mode)</li> <li>Distance: TX-RX gap set to 2.5 meters</li> <li>Test Phases:</li> <li>Room empty (baseline data)</li> <li>Person standing still in center</li> <li>Person walking slowly across the room</li> </ul>"},{"location":"applications/human-detection/#3-csi-signal-behavior","title":"3. CSI Signal Behavior","text":""},{"location":"applications/human-detection/#empty-room","title":"Empty Room:","text":"<ul> <li>CSI amplitude is flat</li> <li>Phase variation is minimal and mostly due to noise</li> </ul>"},{"location":"applications/human-detection/#person-present","title":"Person Present:","text":"<ul> <li>CSI amplitude shows slight but measurable fluctuation</li> <li>Unwrapped phase shows subtle low-frequency oscillation</li> </ul>"},{"location":"applications/human-detection/#person-walking","title":"Person Walking:","text":"<ul> <li>Rapid phase and amplitude variation</li> <li>Higher frequency components appear in signal spectrum</li> </ul>"},{"location":"applications/human-detection/#4-detection-techniques","title":"4. Detection Techniques","text":"<ul> <li>Compute amplitude variance or standard deviation over time</li> <li>Apply a low-pass filter to remove high-frequency noise</li> <li>Compare current window\u2019s statistics to baseline profile</li> <li>Use a binary threshold or machine learning classifier (e.g., SVM)</li> </ul>"},{"location":"applications/human-detection/#5-sample-output","title":"5. Sample Output","text":""},{"location":"applications/human-detection/#time-rssi-amplitude-var-2024-06-01-100321540-51-0027-2024-06-01-100322540-51-0030-2024-06-01-100323540-51-0052-person-entered-room","title":"<pre><code>Time, RSSI, Amplitude Var\n2024-06-01 10:03:21.540, -51, 0.027\n2024-06-01 10:03:22.540, -51, 0.030\n2024-06-01 10:03:23.540, -51, 0.052  &lt;-- person entered room\n</code></pre>","text":""},{"location":"applications/human-detection/#summary","title":"Summary","text":"<p>CSI-based human presence detection leverages subtle shifts in amplitude and phase to identify occupancy in a space. It is a low-cost, privacy-preserving alternative to vision-based systems and can serve as the foundation for smart home or building automation features.</p>"},{"location":"challenges/challenges/","title":"Challenges Faced","text":"<p>While implementing CSI-based sensing using the ESP32-CSI Tool, several technical and practical challenges were encountered during experimentation and deployment. These challenges span hardware limitations, data consistency, and environmental factors.</p>"},{"location":"challenges/challenges/#1-hardware-limitations","title":"1. Hardware Limitations","text":""},{"location":"challenges/challenges/#a-uart-bandwidth","title":"A. UART Bandwidth","text":"<ul> <li>High CSI sampling rates produce large amounts of data</li> <li>The ESP32 UART struggles at lower baud rates</li> <li>Required use of high-speed rates (\u2265921600), which are not always stable across devices</li> </ul>"},{"location":"challenges/challenges/#b-memory-constraints","title":"B. Memory Constraints","text":"<ul> <li>Limited RAM on ESP32 makes buffering long CSI frames difficult</li> <li>Cannot support continuous high-rate CSI logging without pauses or drops</li> </ul>"},{"location":"challenges/challenges/#c-no-native-timestamp","title":"C. No Native Timestamp","text":"<ul> <li>CSI frames from ESP32 do not include native timestamps</li> <li>Timestamping must be added on host side, introducing alignment errors</li> </ul>"},{"location":"challenges/challenges/#2-environmental-variability","title":"2. Environmental Variability","text":""},{"location":"challenges/challenges/#a-multipath-instability","title":"A. Multipath Instability","text":"<ul> <li>Reflections from furniture, people, or walls cause signal fluctuations</li> <li>Even minor environmental changes can impact phase data stability</li> </ul>"},{"location":"challenges/challenges/#b-signal-interference","title":"B. Signal Interference","text":"<ul> <li>Nearby Wi-Fi networks, mobile hotspots, or Bluetooth devices interfere with CSI capture</li> <li>Requires careful channel selection and isolation</li> </ul>"},{"location":"challenges/challenges/#3-data-processing-issues","title":"3. Data Processing Issues","text":""},{"location":"challenges/challenges/#a-phase-wrapping","title":"A. Phase Wrapping","text":"<ul> <li>Phase values are wrapped within \\( \\pm\\pi \\), leading to discontinuities</li> <li>Requires robust unwrapping and detrending logic</li> </ul>"},{"location":"challenges/challenges/#b-subcarrier-noise","title":"B. Subcarrier Noise","text":"<ul> <li>Not all subcarriers are equally reliable</li> <li>Selecting the most stable subcarriers requires manual testing or heuristics</li> </ul>"},{"location":"challenges/challenges/#c-synchronization-gaps","title":"C. Synchronization Gaps","text":"<ul> <li>Multi-device setups (for localization or tracking) require synchronized clocks</li> <li>ESP32 lacks precise time synchronization unless external methods are added</li> </ul>"},{"location":"challenges/challenges/#4-software-and-tooling-challenges","title":"4. Software and Tooling Challenges","text":"<ul> <li>ESP-IDF version compatibility with CSI firmware</li> <li>Limited support for real-time filtering and visualization in the default tool</li> <li>Logging format varies slightly across modes (active_ap, active_sta, passive)</li> </ul>"},{"location":"challenges/challenges/#5-overcoming-the-challenges","title":"5. Overcoming the Challenges","text":""},{"location":"challenges/challenges/#uart-bandwidth","title":"UART Bandwidth","text":"<ul> <li>Used higher baud rate (921600 or 1152000) for UART to prevent data loss.</li> <li>Ensured serial monitor tools (like <code>idf.py monitor</code>) are configured to handle this rate.</li> </ul>"},{"location":"challenges/challenges/#memory-constraints","title":"Memory Constraints","text":"<ul> <li>Kept CSI processing minimal on-device.</li> <li>Offloaded preprocessing to host side to avoid RAM bottlenecks.</li> </ul>"},{"location":"challenges/challenges/#timestamps","title":"Timestamps","text":"<ul> <li>Added timestamps using a Python wrapper script on the host system (<code>serial_append_time.py</code>).</li> <li>Customized to prepend high-resolution timestamps.</li> </ul>"},{"location":"challenges/challenges/#phase-wrapping-and-bias","title":"Phase Wrapping and Bias","text":"<ul> <li>Applied phase unwrapping and linear fitting using in-house Python scripts.</li> <li>Used logic inspired by:</li> </ul> <pre><code># Phase unwrapping\nfor i in range(len(phases) - 1):\n    phases[i + 1] = unwrap_phase(phases[i], phases[i + 1])\n\n# Linear fitting\nalpha_1 = (phases[F] - phases[0]) / (2 * pi * F)\nalpha_0 = sum(phases) / F\nfor i in range(len(phases)):\n    phases[i] -= (alpha_1 * i + alpha_0)\n</code></pre>"},{"location":"challenges/challenges/#subcarrier-noise","title":"Subcarrier Noise","text":"<ul> <li>Selected stable subcarriers empirically through visual inspection.</li> <li>Ignored edge subcarriers which tend to be noisier.</li> </ul>"},{"location":"challenges/challenges/#interference-and-multipath","title":"Interference and Multipath","text":"<ul> <li>Performed experiments during idle network hours.</li> <li>Used isolated channels and quiet test environments.</li> </ul>"},{"location":"challenges/challenges/#synchronization-gaps","title":"Synchronization Gaps","text":"<ul> <li>Single-device experiments avoided clock sync issues.</li> <li>For multi-device setups, network time sync or NTP can be integrated.</li> </ul>"},{"location":"challenges/challenges/#summary","title":"Summary","text":"<p>CSI-based sensing offers significant potential, but also presents multiple technical and operational challenges. Addressing them requires careful firmware configuration, robust signal processing, and consistent test environments. Acknowledging and documenting these challenges is key to improving system reliability and performance.</p>"},{"location":"csi-tool/collection-method/","title":"How CSI Data is Collected","text":"<p>The ESP32-CSI Tool collects CSI data by placing the ESP32 Wi-Fi chipset into stationary mode and modifying its internal firmware to expose CSI measurements from received Wi-Fi frames. This process is based on features available in the Espressif SDK but requires specific driver changes that are implemented in the ESP32-CSI Tool firmware.</p>"},{"location":"csi-tool/collection-method/#modes-of-operation","title":"Modes of Operation","text":"<p>The ESP32-CSI Tool provides three main operational modes:</p> <ul> <li><code>active_sta</code>: The ESP32 connects to a router as a client and captures CSI from packets it receives.</li> <li><code>active_ap</code>: The ESP32 acts as an access point and collects CSI from devices transmitting to it.</li> <li><code>passive</code>: The ESP32 operates in a passive listening mode and captures CSI from all frames it overhears on a given Wi-Fi channel.</li> </ul> <p>These modes are available as separate directories in the project and should be selected based on the use case.</p>"},{"location":"csi-tool/collection-method/#steps-involved-in-csi-collection","title":"Steps Involved in CSI Collection","text":"<ol> <li>Firmware Setup: Build and flash the CSI-enabled firmware to the ESP32.</li> <li>Environment Configuration: Set Wi-Fi channel, data rate, and CSI output format using <code>menuconfig</code>.</li> <li>Receiving Packets: ESP32 receives Wi-Fi frames continuously on the configured channel.</li> <li>CSI Extraction: For each frame received, the ESP32 extracts CSI including amplitude and phase per subcarrier.</li> <li>UART Output: The processed CSI data is sent to the host machine via UART.</li> <li>Data Logging: The host system logs the CSI stream using <code>idf.py monitor</code> or a custom serial script.</li> </ol>"},{"location":"csi-tool/collection-method/#important-configuration-parameters-via-menuconfig","title":"Important Configuration Parameters (via <code>menuconfig</code>)","text":"<ul> <li>Channel number (fixed to avoid channel hopping)</li> <li>MAC filter (optional: restrict to packets from a specific transmitter)</li> <li>Data rate (fixed for consistency in analysis)</li> <li>Console baud rate (921600 or higher recommended)</li> <li>FreeRTOS tick rate (set to 1000 Hz)</li> </ul> <p>These parameters are critical to ensure stable, consistent CSI output for post-processing.</p>"},{"location":"csi-tool/collection-method/#output-format-and-logging","title":"Output Format and Logging","text":"<p>CSI data is transmitted as a structured string with metadata (MAC, RSSI, rate, etc.) and subcarrier values. It is logged in plain text or CSV format and optionally piped through timestamping and plotting utilities for further analysis.</p> <p>For additional details, refer to the official documentation at: ESP32-CSI Tool</p>"},{"location":"csi-tool/what-is-csi/","title":"Working of CSI Tool","text":"<p>This section explains the underlying principles and technical background of how the ESP32-CSI Tool functions. It introduces Channel State Information (CSI), compares it with traditional metrics like RSSI, and outlines how CSI is captured using the ESP32 chip.</p>"},{"location":"csi-tool/what-is-csi/#what-is-csi","title":"What is CSI?","text":"<p>Channel State Information (CSI) refers to detailed information about the wireless channel through which a signal travels from a transmitter to a receiver. CSI captures how each subcarrier in an OFDM-based Wi-Fi signal is affected by the surrounding environment.</p> <p>Unlike RSSI (Received Signal Strength Indicator), which gives a single value for signal strength, CSI provides: - Amplitude and phase for each subcarrier - Per-packet frequency-domain data - Real-time responsiveness to small environmental changes</p>"},{"location":"csi-tool/what-is-csi/#why-csi-matters","title":"Why CSI Matters","text":"<p>CSI enables fine-grained sensing, making it useful for applications like: - Human presence detection - Breathing rate estimation - Gesture recognition - Indoor localization</p>"},{"location":"csi-tool/what-is-csi/#csi-vs-rssi","title":"CSI vs. RSSI","text":"Feature RSSI CSI Data Granularity Single value Per subcarrier (e.g., 52 for 20 MHz) Captures Phase No Yes Use Cases Connectivity estimation Sensing, tracking, motion detection Sensitivity Low High (reacts to small physical changes)"},{"location":"csi-tool/what-is-csi/#how-csi-is-captured-by-esp32","title":"How CSI is Captured by ESP32","text":"<p>The ESP32-CSI Tool works by enabling receiving(AP) mode on the ESP32\u2019s Wi-Fi chipset and extracting CSI data from received packets. The firmware modifies low-level Wi-Fi driver functions to expose CSI data via UART.</p>"},{"location":"csi-tool/what-is-csi/#process-overview","title":"Process Overview","text":"<ol> <li>ESP32 receives Wi-Fi packets in receiving(AP) mode</li> <li>CSI extraction is triggered per frame</li> <li>Data is formatted into UART strings with MAC info, RSSI, amplitude, and phase</li> <li>UART stream is logged on the host machine</li> </ol>"},{"location":"csi-tool/what-is-csi/#csi-packet-structure","title":"CSI Packet Structure","text":"<p>The CSI packet format in the ESP32-CSI Tool is based on the <code>_wifi_csi_cb()</code> callback and the <code>wifi_csi_info_t</code> structure in the ESP-IDF. Each CSI output line begins with <code>CSI_DATA,</code> and includes metadata fields followed by raw CSI values.</p> <p>CSV Header Format:</p> <p>type,role,mac,rssi,rate,sig_mode,mcs,bandwidth,smoothing, not_sounding,aggregation,stbc,fec_coding,sgi,noise_floor, ampdu_cnt,channel,secondary_channel,local_timestamp,ant, sig_len,rx_state,real_time_set,real_timestamp,len,CSI_DATA</p> <p>CSI Data Modes:</p> <p>The output of data-&gt;buf depends on compile-time configuration macros:</p> <ul> <li><code>CSI_RAW</code>: Outputs raw I/Q values in interleaved form: I1 Q1 I2 Q2 ...</li> <li><code>CSI_AMPLITUDE</code>: Computes amplitude as sqrt(I\u00b2 + Q\u00b2) per subcarrier</li> <li><code>CSI_PHASE</code>: Computes instantaneous phase as atan2(Q, I) per subcarrier</li> </ul> <p>These modes provide flexibility based on your sensing or research needs. Output can be tailored for low-latency logging, high-resolution signal reconstruction, or phase-based inference.</p> <p>Notes:</p> <ul> <li>Timestamp is derived from rx_ctrl.timestamp and enhanced by host-side logging</li> <li>MAC address and channel info are embedded for filtering and labeling</li> <li>Noise floor, SNR, and signal length help evaluate CSI quality</li> </ul>"},{"location":"csi-tool/what-is-csi/#sample-csi-output","title":"Sample CSI Output","text":"<p>Example with CSI_RAW:</p> <p><code>CSI_DATA,active_sta,84:f3:eb:12:34:56,-47,26,1,0,1,1,0,0,0,0,1,-95,3,1,0,123456789,0,128,1,1,1685735234576,114,[8 -4 7 1 9 3 10 5 13 6 16 6 17 3 15 1 12 -2 10 -3 ...]</code></p> <p>With CSI_AMPLITUDE:</p> <p><code>CSI_DATA,active_sta,84:f3:eb:12:34:56,-47,26,1,0,1,1,0,0,0,0,1,-95,3,1,0,123456789,0,128,1,1,1685735234576,57,[9 7 9 11 15 17 17 15 12 10 ...]</code></p> <p>With CSI_PHASE:</p> <p><code>CSI_DATA,active_sta,84:f3:eb:12:34:56,-47,26,1,0,1,1,0,0,0,0,1,-95,3,1,0,123456789,0,128,1,1,1685735234576,57,[1 -2 0 1 2 3 2 1 -1 -3 ...]</code></p>"},{"location":"csi-tool/what-is-csi/#description-of-fields","title":"Description of Fields","text":"Field Description type Always CSI_DATA role Project role (e.g., active_sta, passive) mac MAC address of sender rssi Received Signal Strength Indicator rate Data rate (hex value) sig_mode Wi-Fi signal mode (0: legacy, 1: HT) mcs Modulation and Coding Scheme bandwidth 0 = 20 MHz, 1 = 40 MHz smoothing Whether smoothing is used not_sounding Packet is not sounding aggregation Frame was aggregated stbc Space-Time Block Coding fec_coding FEC (e.g., LDPC) used sgi Short Guard Interval used noise_floor Estimated noise floor ampdu_cnt Aggregated MPDU count channel Wi-Fi channel secondary_channel Secondary channel indicator local_timestamp Timestamp from Wi-Fi packet ant Antenna index sig_len Signal length rx_state RX state bitmask real_time_set Indicates if real timestamp is valid real_timestamp Millisecond timestamp from steady clock len Length of CSI buffer in bytes CSI_DATA Either raw I/Q pairs, amplitudes, or phases"},{"location":"csi-tool/what-is-csi/#how-this-data-is-used","title":"How This Data is Used","text":"<p>Depending on the configuration, CSI data can be analyzed in various ways:</p> <p>Raw I/Q Data: Used for full physical layer modeling and filtering</p> <p>Amplitude: Good for presence detection, gesture recognition, basic signal strength visualization</p> <p>Phase: Used for fine-grained motion sensing, breathing rate estimation, or indoor localization</p> <p>Post-processing may include:</p> <ul> <li> <p>Phase unwrapping and linear detrending</p> </li> <li> <p>Amplitude smoothing</p> </li> <li> <p>Subcarrier selection</p> </li> <li> <p>FFT or peak counting for periodic signals (e.g., respiration)</p> </li> </ul>"},{"location":"csi-tool/what-is-csi/#summary","title":"Summary","text":"<p>CSI enables advanced wireless sensing by providing rich signal characteristics per packet. Compared to RSSI, CSI is more informative and allows for fine-grained tracking of environmental changes.</p> <p>The ESP32-CSI Tool extracts CSI from Wi-Fi frames in real time and outputs it via UART, making it accessible for logging, analysis, and machine learning applications.</p>"},{"location":"csi-tool/what-is-csi_copy/","title":"Working of CSI Tool","text":"<p>This section explains the underlying principles and technical background of how the ESP32-CSI Tool functions. It introduces Channel State Information (CSI), compares it with traditional metrics like RSSI, and outlines how CSI is captured using the ESP32 chip.</p>"},{"location":"csi-tool/what-is-csi_copy/#what-is-csi","title":"What is CSI?","text":"<p>Channel State Information (CSI) refers to detailed information about the wireless channel through which a signal travels from a transmitter to a receiver. CSI captures how each subcarrier in an OFDM-based Wi-Fi signal is affected by the surrounding environment.</p> <p>Unlike RSSI (Received Signal Strength Indicator), which gives a single value for signal strength, CSI provides: - Amplitude and phase for each subcarrier - Per-packet frequency-domain data - Real-time responsiveness to small environmental changes</p>"},{"location":"csi-tool/what-is-csi_copy/#why-csi-matters","title":"Why CSI Matters","text":"<p>CSI enables fine-grained sensing, making it useful for applications like: - Human presence detection - Breathing rate estimation - Gesture recognition - Indoor localization</p>"},{"location":"csi-tool/what-is-csi_copy/#csi-vs-rssi","title":"CSI vs. RSSI","text":"Feature RSSI CSI Data Granularity Single value Per subcarrier (e.g., 52 for 20 MHz) Captures Phase No Yes Use Cases Connectivity estimation Sensing, tracking, motion detection Sensitivity Low High (reacts to small physical changes)"},{"location":"csi-tool/what-is-csi_copy/#how-csi-is-captured-by-esp32","title":"How CSI is Captured by ESP32","text":"<p>The ESP32-CSI Tool works by enabling receiving(AP) mode on the ESP32\u2019s Wi-Fi chipset and extracting CSI data from received packets. The firmware modifies low-level Wi-Fi driver functions to expose CSI data via UART.</p>"},{"location":"csi-tool/what-is-csi_copy/#process-overview","title":"Process Overview","text":"<ol> <li>ESP32 receives Wi-Fi packets in receiving(AP) mode</li> <li>CSI extraction is triggered per frame</li> <li>Data is formatted into UART strings with MAC info, RSSI, amplitude, and phase</li> <li>UART stream is logged on the host machine</li> </ol>"},{"location":"csi-tool/what-is-csi_copy/#csi-packet-structure","title":"CSI Packet Structure","text":"<p>Each CSI message from the ESP32 includes: - Timestamp - MAC address - RSSI - Channel and rate info - CSI payload (complex values for each subcarrier)</p> <p>The data is typically parsed and saved in CSV format or visualized live using Python scripts.</p>"},{"location":"csi-tool/what-is-csi_copy/#sample-csi-output","title":"Sample CSI Output","text":"<pre><code>CSI_DATA, MAC=84:f3:eb:12:34:56, CH=1, RSSI=-47, RATE=0x1a, SIG_MODE=1, MCS=0, CWB=1, SNR=42, Noise Floor=-95\nCSI_LEN=114, CHAN=1, Secondary Channel=0, RSSI=-47, First Word=242\nTimestamp: 1685735234576\nCSI: \n8,-4 7,1 9,3 10,5 13,6 16,6 17,3 15,1 12,-2 10,-3 ...\n</code></pre>"},{"location":"csi-tool/what-is-csi_copy/#description-of-fields","title":"Description of Fields","text":"Field Description MAC MAC address of the transmitter CH Wi-Fi channel number RSSI Received Signal Strength Indicator (dBm) RATE, MCS Transmission rate and Modulation and Coding Scheme SIG_MODE Signal mode (1 = HT, 0 = legacy) CWB Channel Bandwidth (1 = 40 MHz, 0 = 20 MHz) SNR, Noise Floor Signal-to-Noise Ratio and reference baseline CSI_LEN Number of subcarriers captured Timestamp Time of packet capture (ms) CSI List of complex pairs (I, Q) per subcarrier"},{"location":"csi-tool/what-is-csi_copy/#how-this-data-is-used","title":"How This Data is Used","text":"<ul> <li>Amplitude: <code>sqrt(I\u00b2 + Q\u00b2)</code> for each subcarrier</li> <li>Phase: <code>atan2(Q, I)</code> after unwrapping and filtering</li> <li>Can be plotted over time to detect motion, respiration, etc.</li> </ul>"},{"location":"csi-tool/what-is-csi_copy/#summary","title":"Summary","text":"<p>CSI enables advanced wireless sensing by providing rich signal characteristics per packet. Compared to RSSI, CSI is more informative and allows for fine-grained tracking of environmental changes.</p> <p>The ESP32-CSI Tool extracts CSI from Wi-Fi frames in real time and outputs it via UART, making it accessible for logging, analysis, and machine learning applications.</p>"},{"location":"data-analysis/preprocessing/","title":"Data Analysis: Preprocessing","text":"<p>This section describes how to preprocess CSI data collected using the ESP32-CSI Tool to obtain clean, usable phase signals for further analysis. The process includes phase unwrapping and linear fitting based on techniques implemented in the custom RayIoT toolchain.</p>"},{"location":"data-analysis/preprocessing/#1-why-preprocess-phase-data","title":"1. Why Preprocess Phase Data?","text":"<p>The phase values derived from raw I/Q pairs are wrapped between \\(-\\pi\\) and \\(\\pi\\). These discontinuities affect continuity and trend analysis. Additionally, hardware-induced distortions can bias phase lines. Preprocessing improves phase consistency and removes noise.</p>"},{"location":"data-analysis/preprocessing/#2-converting-iq-to-amplitude-and-phase","title":"2. Converting I/Q to Amplitude and Phase","text":"<p>Raw CSI data is output as interleaved I (in-phase) and Q (quadrature) samples for each subcarrier. These need to be separated and converted to amplitude and phase:</p> <pre><code>import numpy as np\nfrom math import sqrt, atan2\n\n# Example: interleaved IQ values from a CSI line\ncsi_raw = [8, -4, 7, 1, 9, 3, 10, 5]  # I1,Q1, I2,Q2, ...\n\ni_vals = csi_raw[0::2]  # even indices = I\nq_vals = csi_raw[1::2]  # odd indices = Q\n\namplitudes = [sqrt(i**2 + q**2) for i, q in zip(i_vals, q_vals)]\nphases = [atan2(q, i) for i, q in zip(i_vals, q_vals)]\n</code></pre> <p>These amplitude and phase values serve as the foundation for all further analysis.</p>"},{"location":"data-analysis/preprocessing/#3-phase-unwrapping","title":"3. Phase Unwrapping","text":"<p>Wrapped phase data causes abrupt jumps near \\(\\pm\\pi\\). Unwrapping reconstructs continuous phase:</p> <pre><code>def unwrap_phase(current_phase, next_phase):\n    delta = next_phase - current_phase\n    if delta &gt; math.pi:\n        next_phase = current_phase + delta - (2 * math.pi)\n    elif delta &lt; -math.pi:\n        next_phase = current_phase + delta + (2 * math.pi)\n    return next_phase\n\n# Apply to entire array\nfor i in range(len(phases) - 1):\n    phases[i + 1] = unwrap_phase(phases[i], phases[i + 1])\n</code></pre>"},{"location":"data-analysis/preprocessing/#3-linear-fitting-to-remove-bias","title":"3. Linear Fitting to Remove Bias","text":"<p>To remove hardware offset trends, a linear fit is applied to the unwrapped phase using the following equation:</p> \\[ \\phi_f = \\phi_f - (\\alpha_1 \\cdot f + \\alpha_0) \\] <p>Where:</p> \\[ \\alpha_1 = \\frac{\\phi_F - \\phi_1}{2\\pi F}, \\quad  \\alpha_0 = \\frac{1}{F} \\sum_{f=1}^{F} \\phi_f \\]"},{"location":"data-analysis/preprocessing/#explanation-of-terms","title":"Explanation of Terms","text":"<ul> <li>\\(\\phi_f\\): The unwrapped phase value at subcarrier index f (in radians). This represents the raw phase reading after removing discontinuities.</li> <li>\\(f\\): Index of the subcarrier, ranging from 1 to F (total number of subcarriers).</li> <li>\\(\\alpha_1\\): Slope of the linear phase trend across subcarriers, typically caused by hardware imperfections.</li> <li>\\(\\alpha_0\\): Offset (intercept) of the phase trend line.</li> </ul> <p>This equation subtracts the best-fit line (trend) from each phase value to flatten the phase response across subcarriers.</p> <p>The slope and offset are computed as:</p> \\[ \\alpha_1 = \\frac{\\phi_F - \\phi_1}{2\\pi F}, \\quad \\alpha_0 = \\frac{1}{F} \\sum_{f=1}^{F} \\phi_f \\]"},{"location":"data-analysis/preprocessing/#explanation-of-terms_1","title":"Explanation of Terms","text":"<ul> <li>\\(\\phi_1\\): Phase of the first subcarrier.</li> <li>\\(\\phi_F\\): Phase of the last subcarrier.</li> <li>\\(F\\): Total number of subcarriers (e.g., 52 for 20 MHz bandwidth).</li> <li>\\(\\alpha_1\\): Approximates the rate of phase change across subcarriers.</li> <li>\\(\\alpha_0\\): Mean phase across all subcarriers.</li> </ul>"},{"location":"data-analysis/preprocessing/#summary","title":"Summary","text":"<p>These equations are used to remove the consistent hardware-induced linear bias from phase data. After correction:</p> <ul> <li>The phase becomes more stable and accurate.</li> <li>It's better suited for motion detection, breathing estimation, and other sensing applications.</li> </ul> <p>This preprocessing step is crucial for using CSI phase information effectively.</p>"},{"location":"data-analysis/preprocessing/#4-when-to-apply","title":"4. When to Apply","text":"<p>Apply these preprocessing steps immediately after converting I/Q pairs to phase values, and before any filtering or machine learning.</p>"},{"location":"data-analysis/preprocessing/#summary_1","title":"Summary","text":"<p>Preprocessing of CSI phase data is critical to ensure meaningful analysis. Phase unwrapping eliminates discontinuities, and linear fitting corrects hardware-induced distortions. This results in cleaner, smoother signals better suited for downstream analysis or classification tasks.</p>"},{"location":"data-analysis/raw-format/","title":"Data Analysis: Raw CSI Format","text":"<p>This section explains the structure and content of raw Channel State Information (CSI) output from the ESP32-CSI Tool. Understanding this format is essential for parsing, filtering, and visualizing the data.</p>"},{"location":"data-analysis/raw-format/#1-structure-of-a-csi-data-packet","title":"1. Structure of a CSI Data Packet","text":"<p>The CSI packet format in the ESP32-CSI Tool is based on the <code>_wifi_csi_cb()</code> callback and the <code>wifi_csi_info_t</code> structure in the ESP-IDF. Each CSI output line begins with <code>CSI_DATA,</code> and includes metadata fields followed by raw CSI values. </p> <p>CSV Header Format:</p> <p>type,role,mac,rssi,rate,sig_mode,mcs,bandwidth,smoothing, not_sounding,aggregation,stbc,fec_coding,sgi,noise_floor, ampdu_cnt,channel,secondary_channel,local_timestamp,ant, sig_len,rx_state,real_time_set,real_timestamp,len,CSI_DATA</p> <p>CSI Data Modes:</p> <p>The output of data-&gt;buf depends on compile-time configuration macros:</p> <ul> <li><code>CSI_RAW</code>: Outputs raw I/Q values in interleaved form: I1 Q1 I2 Q2 ... </li> <li><code>CSI_AMPLITUDE</code>: Computes amplitude as sqrt(I\u00b2 + Q\u00b2) per subcarrier</li> <li><code>CSI_PHASE</code>: Computes instantaneous phase as atan2(Q, I) per subcarrier</li> </ul> <p>These modes provide flexibility based on your sensing or research needs. Output can be tailored for low-latency logging, high-resolution signal reconstruction, or phase-based inference.</p> <p>Notes:</p> <ul> <li>Timestamp is derived from rx_ctrl.timestamp and enhanced by host-side logging</li> <li>MAC address and channel info are embedded for filtering and labeling</li> <li>Noise floor, SNR, and signal length help evaluate CSI quality</li> </ul>"},{"location":"data-analysis/raw-format/#example-raw-output","title":"Example Raw Output:","text":"<pre><code>`CSI_DATA,active_sta,84:f3:eb:12:34:56,-47,26,1,0,1,1,0,0,0,0,1,-95,3,1,0,123456789,0,128,1,1,1685735234576,114,[8 -4 7 1 9 3 10 5 13 6 16 6 17 3 15 1 12 -2 10 -3 ...]`\n</code></pre>"},{"location":"data-analysis/raw-format/#2-metadata-field-descriptions","title":"2. Metadata Field Descriptions","text":"Field Description type Always CSI_DATA role Project role (e.g., active_sta, passive) mac MAC address of sender rssi Received Signal Strength Indicator rate Data rate (hex value) sig_mode Wi-Fi signal mode (0: legacy, 1: HT) mcs Modulation and Coding Scheme bandwidth 0 = 20 MHz, 1 = 40 MHz smoothing Whether smoothing is used not_sounding Packet is not sounding aggregation Frame was aggregated stbc Space-Time Block Coding fec_coding FEC (e.g., LDPC) used sgi Short Guard Interval used noise_floor Estimated noise floor ampdu_cnt Aggregated MPDU count channel Wi-Fi channel secondary_channel Secondary channel indicator local_timestamp Timestamp from Wi-Fi packet ant Antenna index sig_len Signal length rx_state RX state bitmask real_time_set Indicates if real timestamp is valid real_timestamp Millisecond timestamp from steady clock len Length of CSI buffer in bytes CSI_DATA Either raw I/Q pairs, amplitudes, or phases"},{"location":"data-analysis/raw-format/#3-csi-payload-format","title":"3. CSI Payload Format","text":"<p>The CSI line consists of a flat sequence of complex-valued pairs representing the I (in-phase) and Q (quadrature) components for each subcarrier:</p> <pre><code>CSI: I1,Q1 I2,Q2 I3,Q3 ... In,Qn\n</code></pre> <p>These values represent the channel\u2019s response across frequency and are later used to derive amplitude and phase.</p>"},{"location":"data-analysis/raw-format/#amplitude","title":"Amplitude:","text":"<pre><code>Amplitude = sqrt(I^2 + Q^2)\n</code></pre>"},{"location":"data-analysis/raw-format/#phase","title":"Phase:","text":"<pre><code>Phase = atan2(Q, I)\n</code></pre> <p>Phase data often requires additional unwrapping and linear fitting to remove hardware bias and noise.</p>"},{"location":"data-analysis/raw-format/#4-notes-on-parsing-and-resolution","title":"4. Notes on Parsing and Resolution","text":"<ul> <li>A 20 MHz channel usually provides 52 subcarriers (26 left, 26 right of center)</li> <li>ESP32 CSI output may vary depending on mode (active/passive), firmware version, and ESP-IDF</li> <li>Some fields like <code>SNR</code> or <code>Noise Floor</code> may be placeholder values unless explicitly enabled in firmware</li> </ul>"},{"location":"data-analysis/raw-format/#5-typical-range-of-values","title":"5. Typical Range of Values","text":""},{"location":"data-analysis/raw-format/#iq-samples","title":"I/Q Samples","text":"<ul> <li>I/Q pairs usually range from -128 to +127</li> <li>Represent 8-bit signed integer values depending on ESP32 ADC resolution and format</li> </ul>"},{"location":"data-analysis/raw-format/#amplitude-values","title":"Amplitude Values","text":"<ul> <li>Generally fall between 0 to ~180 depending on movement, multipath, and distance</li> </ul>"},{"location":"data-analysis/raw-format/#phase-values","title":"Phase Values","text":"<ul> <li>Range from -\u03c0 to +\u03c0 (in radians) before unwrapping</li> <li>After processing, can be used to detect Doppler shifts or relative motion</li> </ul>"},{"location":"data-analysis/raw-format/#summary","title":"Summary","text":"<p>Raw CSI format includes a metadata header followed by a flat list of I/Q pairs. These complex values are the foundation for computing signal amplitude and phase per subcarrier and are essential for building CSI-based sensing and inference systems.</p>"},{"location":"data-analysis/visualization/","title":"Data Analysis: Plotting and Visualization","text":"<p>This section describes how to visualize CSI data collected from the ESP32-CSI Tool to extract meaningful patterns, trends, and signal behaviors.</p>"},{"location":"data-analysis/visualization/#1-tools-required","title":"1. Tools Required","text":"<p>Before plotting, ensure the following Python packages are installed:</p> <pre><code>pip install numpy matplotlib pandas\n</code></pre> <p>You may also use Jupyter Notebook for interactive analysis:</p> <pre><code>pip install notebook\njupyter notebook\n</code></pre>"},{"location":"data-analysis/visualization/#2-data-preparation","title":"2. Data Preparation","text":"<p>Typically, CSI data is logged in a <code>.csv</code> file using <code>idf.py monitor | grep \"CSI_DATA\" &gt; csi_output.csv</code> or with a timestamped script.</p> <p>Ensure your CSV file has rows formatted like:</p> <pre><code>Timestamp, MAC, RSSI, CSI_Length, I1,Q1, I2,Q2, ..., In,Qn\n</code></pre> <p>Use <code>serial_to_dataframe.py</code> from the ESP32-CSI-Tool <code>python_utils/</code> directory to convert raw serial logs into a structured DataFrame.</p>"},{"location":"data-analysis/visualization/#3-plotting-amplitude-per-subcarrier","title":"3. Plotting Amplitude per Subcarrier","text":"<pre><code>import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load structured CSV\ndf = pd.read_csv(\"csi_output.csv\")\n\n# Extract I/Q values and compute amplitude\nnum_subcarriers = 52\nfor index, row in df.iterrows():\n    iq_pairs = np.array(row[4:4+2*num_subcarriers]).astype(int)\n    i_vals = iq_pairs[0::2]\n    q_vals = iq_pairs[1::2]\n    amplitude = np.sqrt(i_vals**2 + q_vals**2)\n\n    plt.plot(range(len(amplitude)), amplitude, label=f\"Packet {index}\")\n    if index == 10:  # limit to first 10 plots for clarity\n        break\n\nplt.title(\"CSI Amplitude across Subcarriers\")\nplt.xlabel(\"Subcarrier Index\")\nplt.ylabel(\"Amplitude\")\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"data-analysis/visualization/#4-live-visualization-optional","title":"4. Live Visualization (Optional)","text":"<p>The ESP32-CSI Tool includes <code>serial_plot_csi_live.py</code> for real-time plotting:</p> <pre><code>python python_utils/serial_plot_csi_live.py\n</code></pre> <p>You can also modify it to highlight specific subcarriers or track phase over time.</p>"},{"location":"data-analysis/visualization/#5-visualizing-phase","title":"5. Visualizing Phase","text":"<p>After unwrapping and filtering phase data, you can visualize relative movement or Doppler shifts.</p> <pre><code>phase = np.arctan2(q_vals, i_vals)\nplt.plot(range(len(phase)), phase)\nplt.title(\"Phase per Subcarrier\")\nplt.xlabel(\"Subcarrier Index\")\nplt.ylabel(\"Phase (radians)\")\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"data-analysis/visualization/#6-sample-visualization-outputs","title":"6. Sample Visualization Outputs","text":"<p>Below are examples of how CSI data might look when plotted:</p>"},{"location":"data-analysis/visualization/#amplitude-vs-packets-single-frame","title":"Amplitude vs packets (Single Frame):","text":""},{"location":"data-analysis/visualization/#phase-vs-packets-single-frame","title":"Phase vs packets (Single Frame):","text":"<p>These visualizations are helpful in analyzing: - Multipath fading and signal distortion - Breathing waveforms (in phase plots over time) - Signal stability across static environments</p>"},{"location":"data-analysis/visualization/#summary","title":"Summary","text":"<p>CSI visualization is essential for interpreting signal characteristics. Start with amplitude plots to observe motion or environment changes, and explore phase to understand fine-grained effects like respiration or Doppler shifts.</p>"},{"location":"data-collection/collecting-csi/","title":"Collecting CSI Data","text":"<p>Once the ESP32 is configured and flashed with the CSI-enabled firmware, you can begin collecting CSI data using either serial output or onboard SD card logging (if supported by the board).</p> <p>This section outlines methods for capturing CSI data in real time.</p>"},{"location":"data-collection/collecting-csi/#1-using-idfpy-monitor","title":"1. Using <code>idf.py monitor</code>","text":"<p>This is the simplest way to view and capture CSI output from the ESP32.</p>"},{"location":"data-collection/collecting-csi/#start-the-monitor","title":"Start the monitor:","text":"<pre><code>idf.py monitor\n</code></pre> <p>This will show real-time serial output, including CSI data if your configuration is correct.</p> <p>To exit the monitor, press: <pre><code>Ctrl + ]\n</code></pre></p>"},{"location":"data-collection/collecting-csi/#2-logging-csi-data-to-a-file","title":"2. Logging CSI Data to a File","text":"<p>You can redirect CSI output to a file using standard shell tools.</p>"},{"location":"data-collection/collecting-csi/#on-linuxmacos","title":"On Linux/macOS:","text":"<pre><code>idf.py monitor | grep \"CSI_DATA\" &gt; csi_output.csv\n</code></pre>"},{"location":"data-collection/collecting-csi/#on-windows-powershell","title":"On Windows (PowerShell):","text":"<pre><code>idf.py monitor | findstr \"CSI_DATA\" &gt; csi_output.csv\n</code></pre> <p>This will capture only lines containing CSI readings and store them in a CSV file.</p>"},{"location":"data-collection/collecting-csi/#3-adding-timestamps-optional","title":"3. Adding Timestamps (Optional)","text":"<p>The ESP32 does not attach timestamps to CSI packets. To correlate CSI with time, use the <code>serial_append_time.py</code> script.</p>"},{"location":"data-collection/collecting-csi/#example","title":"Example:","text":"<pre><code>idf.py monitor | python ../python_utils/serial_append_time.py &gt; csi_output_timed.csv\n</code></pre> <p>Each CSI line will be prepended with a UNIX timestamp.</p>"},{"location":"data-collection/collecting-csi/#4-final-way-of-collecting-csi-data","title":"4. Final way of collecting CSI data","text":"<p>The ESP32 does not attach timestamps to CSI packets. Use custom scripts to collect the csi data along with timestamps.</p>"},{"location":"data-collection/collecting-csi/#example_1","title":"Example:","text":"<pre><code>idf.py -p /dev/ttyUSB0 monitor | python ../python_utils/phase_wrapped_filter_linear_fitting_v0.1.py &gt; sample-1.csv\n</code></pre> <p>Each CSI line will be prepended with a UNIX timestamp.</p> <p>Download Sample Output: sample-1.csv</p>"},{"location":"data-collection/collecting-csi/#5-sd-card-logging-optional","title":"5. SD Card Logging (Optional)","text":"<p>If using a board like the TTGO T8 with microSD support: - CSI data can be stored directly to a text or CSV file on the SD card - This is useful for mobile or battery-powered experiments</p> <p>Refer to <code>active_sta/sd_logger.c</code> or related examples in the ESP32-CSI Tool repository.</p>"},{"location":"data-collection/collecting-csi/#6-monitoring-stability","title":"6. Monitoring Stability","text":"<ul> <li>Ensure baud rate in your terminal matches what was configured in <code>menuconfig</code></li> <li>Minimize system load on your host to avoid dropped packets</li> <li>If CSI stops or stutters, restart the monitor and reset the ESP32</li> </ul>"},{"location":"data-collection/collecting-csi/#summary","title":"Summary","text":"<p>CSI data can be collected either over serial (using <code>idf.py monitor</code>) or by logging to a file. Timestamps can be added for analysis using Python scripts. For field tests, boards with SD card support can store CSI data locally.</p>"},{"location":"data-collection/esp32-configuration/","title":"Configuration of ESP32","text":"<p>This section describes how to configure your ESP32 boards to collect Channel State Information (CSI) data using the ESP32-CSI Tool. Configuration is done through the ESP-IDF\u2019s <code>menuconfig</code> interface prior to building and flashing the firmware.</p>"},{"location":"data-collection/esp32-configuration/#1-launch-menuconfig","title":"1. Launch menuconfig","text":"<p>Navigate to your ESP32-CSI Tool project directory and run:</p> <pre><code>idf.py menuconfig\n</code></pre> <p>This opens a terminal-based configuration menu.</p>"},{"location":"data-collection/esp32-configuration/#2-key-configuration-settings","title":"2. Key Configuration Settings","text":"<p>Below are the essential settings to be modified:</p>"},{"location":"data-collection/esp32-configuration/#a-enable-csi","title":"A. Enable CSI","text":"<ul> <li>Navigate to: <code>Component config \u2192 Wi-Fi</code></li> <li>Enable: <code>Enable Wi-Fi CSI (Channel State Information)</code></li> </ul>"},{"location":"data-collection/esp32-configuration/#b-set-wi-fi-channel","title":"B. Set Wi-Fi Channel","text":"<ul> <li>Choose a fixed Wi-Fi channel (e.g., channel 1, 6, or 11)</li> <li>Ensure your router or transmitting device is using the same channel</li> </ul>"},{"location":"data-collection/esp32-configuration/#c-set-serial-flasher-baud-rate","title":"C. Set Serial Flasher Baud Rate","text":"<ul> <li>Navigate to: <code>Serial flasher config</code></li> <li>Set: <code>921600</code> or higher (<code>1152000</code> recommended for better throughput)</li> </ul>"},{"location":"data-collection/esp32-configuration/#d-console-baud-rate","title":"D. Console Baud Rate","text":"<ul> <li>Set console output to match the flash baud rate</li> <li>Typically: <code>921600</code> or <code>1152000</code></li> </ul>"},{"location":"data-collection/esp32-configuration/#e-freertos-tick-rate","title":"E. FreeRTOS Tick Rate","text":"<ul> <li>Navigate to: <code>Component config \u2192 FreeRTOS</code></li> <li>Set: <code>Tick rate (Hz)</code> to <code>1000</code></li> </ul>"},{"location":"data-collection/esp32-configuration/#f-mac-filter-optional","title":"F. MAC Filter (Optional)","text":"<ul> <li>Some modes allow filtering CSI by source MAC address</li> <li>Can be used to isolate CSI from a specific transmitter</li> </ul>"},{"location":"data-collection/esp32-configuration/#3-save-and-exit","title":"3. Save and Exit","text":"<p>After configuration: - Press <code>S</code> to save - Press <code>Q</code> to exit the menu</p> <p>Configuration settings are stored in the <code>sdkconfig</code> file in your project directory.</p>"},{"location":"data-collection/esp32-configuration/#4-rebuild-the-firmware","title":"4. Rebuild the Firmware","text":"<p>After saving your configuration, rebuild and flash the firmware:</p> <pre><code>idf.py build\nidf.py flash\n</code></pre> <p>Make sure to monitor for successful upload and verify CSI output after boot.</p>"},{"location":"data-collection/esp32-configuration/#summary","title":"Summary","text":"<p>Proper configuration of your ESP32 is essential for reliable CSI data collection. Ensure CSI is enabled, Wi-Fi channel is fixed, baud rates are set high, and tick rate is optimized. These settings significantly impact data consistency and integrity.</p>"},{"location":"data-collection/physical-layout/","title":"Data Collection Setup","text":"<p>This section describes how to physically set up your environment and ESP32 devices to reliably collect CSI data using the ESP32-CSI Tool. A consistent and controlled layout is essential for meaningful CSI analysis.</p>"},{"location":"data-collection/physical-layout/#physical-layout","title":"Physical Layout","text":"<p>The quality and consistency of CSI data depends heavily on the physical layout of the devices and the test environment. This includes the placement of the transmitter (TX), receiver (RX), the surrounding space, and sources of interference.</p>"},{"location":"data-collection/physical-layout/#recommended-setup","title":"Recommended Setup","text":"<ul> <li>Use at least two ESP32 boards:</li> <li>One as a transmitter (TX) (e.g., in <code>active_sta</code> mode)</li> <li>One as a receiver (RX) (e.g., in <code>passive</code> or <code>active_ap</code> mode)</li> <li>Place devices on non-metallic, stable surfaces to minimize signal reflections</li> <li>Test both line-of-sight (LoS) and non-line-of-sight (NLoS) scenarios between TX and RX depending on the use case</li> <li>Keep TX and RX at the same height, preferably above the floor (e.g., on tripods)</li> <li>Ensure the room has minimal external interference (e.g., avoid routers and microwaves nearby)</li> </ul>"},{"location":"data-collection/physical-layout/#example-room-setup","title":"Example Room Setup","text":"<ul> <li>Room Size: 4 m x 4 m</li> <li>TX to RX Distance: 1.5 m to 3 m (depending on experiment)</li> <li>Wall materials and furniture should be documented for repeatability</li> <li>External people or moving objects should be minimized during data capture</li> </ul>"},{"location":"data-collection/physical-layout/#example-layout-diagram","title":"Example Layout Diagram","text":"<pre><code>[TX Node]  ---&gt; 1.5m\u20133m ---&gt;  [RX Node connected to logging PC]\n</code></pre>"},{"location":"data-collection/physical-layout/#example-setup-photos","title":"Example Setup Photos","text":"<p>Below are representative images of physical data collection setups.</p> <ul> <li>LoS and NLoS etup with tripod-mounted ESP32 boards:</li> </ul> <p></p> <p>Ensure similar arrangement when replicating experiments. Use printed tape markers or floor guides to maintain repeatable distances and orientation.</p> <p>Place a printed measuring tape or use a grid floor plan to maintain consistent placements between runs.</p>"},{"location":"data-collection/physical-layout/#mounting-guidelines","title":"Mounting Guidelines","text":"<ul> <li>Use tripods or adhesive mounts for fixing ESP32 boards</li> <li>Boards should face each other in parallel if testing direct line-of-sight</li> <li>Use consistent orientations for all tests (same board side facing target)</li> </ul>"},{"location":"data-collection/physical-layout/#environmental-notes","title":"Environmental Notes","text":"<ul> <li>Record environmental conditions: time of day, lighting, temperature (if relevant)</li> <li>Mark any moving sources (fans, doors, etc.)</li> <li>Keep the test area controlled and repeatable</li> </ul>"},{"location":"data-collection/physical-layout/#summary","title":"Summary","text":"<p>A stable and repeatable physical setup is critical for high-quality CSI data collection. Ensure consistent TX-RX distance, minimize interference, and document environmental conditions for every test session.</p>"},{"location":"future/future-work/","title":"Future Work","text":"<p>Although the current implementation of CSI-based sensing using the ESP32-CSI Tool shows promising results for tasks like presence detection and breathing rate estimation, there remain several directions for further improvement and expansion.</p>"},{"location":"future/future-work/#1-multi-person-detection-and-tracking","title":"1. Multi-Person Detection and Tracking","text":"<ul> <li>Extend system capabilities to detect and distinguish multiple people in a room</li> <li>Requires multiple RX nodes and sophisticated phase/amplitude separation techniques</li> <li>Potential use of triangulation and heatmap generation</li> </ul>"},{"location":"future/future-work/#2-integration-with-machine-learning","title":"2. Integration with Machine Learning","text":"<ul> <li>Train ML models (e.g., SVM, CNN, LSTM) on cleaned amplitude/phase features</li> <li>Enable classification tasks such as motion type, activity recognition, or posture detection</li> <li>Incorporate real-time inference on edge or cloud platforms</li> </ul>"},{"location":"future/future-work/#3-real-time-dashboard-and-visualization","title":"3. Real-Time Dashboard and Visualization","text":"<ul> <li>Build a live dashboard to display CSI plots, alerts, and inferences</li> <li>Use web frameworks (Flask, Dash, or Node.js) to stream data from ESP32 to browser</li> <li>Add overlays for BrPM, presence confidence, and subcarrier health</li> </ul>"},{"location":"future/future-work/#4-android-and-mobile-integration","title":"4. Android and Mobile Integration","text":"<ul> <li>Investigate feasibility of receiving CSI from Android Wi-Fi chipsets directly</li> <li>If not possible, build apps that visualize CSI-based outputs from ESP32</li> <li>Sync app display with real-time UART or MQTT feed</li> </ul>"},{"location":"future/future-work/#5-single-device-csi-collection","title":"5. Single-Device CSI Collection","text":"<ul> <li>Explore using a single ESP32 device in <code>active_sta</code> mode connected to a Wi-Fi router to collect CSI data</li> <li>This eliminates the need for a second transmitter or receiver</li> <li>Useful in compact or mobile setups where hardware footprint must be minimized</li> </ul>"},{"location":"future/future-work/#6-long-term-stability-studies","title":"6. Long-Term Stability Studies","text":"<ul> <li>Evaluate CSI stability across hours/days to quantify drift</li> <li>Record environmental changes (e.g., time of day, human activity, temperature)</li> <li>Apply adaptive calibration methods to improve robustness</li> </ul>"},{"location":"future/future-work/#7-miniaturization-and-embedded-deployment","title":"7. Miniaturization and Embedded Deployment","text":"<ul> <li>Port system to low-power or battery-operated ESP32 variants</li> <li>Investigate possibility of standalone SD logging with compact form factor</li> <li>Integrate into IoT frameworks for scalable deployments</li> </ul>"},{"location":"future/future-work/#summary","title":"Summary","text":"<p>The ESP32-CSI Tool lays the foundation for a wide range of contactless sensing applications. With further research, integration, and validation, it can support advanced smart home, healthcare, and security systems. Prioritizing machine learning, mobile deployment, and real-time interfaces will unlock its full potential.</p>"},{"location":"getting-started/environment/","title":"Setting Up the Environment","text":"<p>This section provides a complete walkthrough to set up the development environment required to build, flash, and use the ESP32-CSI Tool on your local machine.</p> <p>It includes ESP-IDF installation, firmware cloning, configuration, and setup for serial monitoring and CSI data capture.</p>"},{"location":"getting-started/environment/#1-prerequisites","title":"1. Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>A stable internet connection</li> <li>An ESP32 DevKit board</li> <li>Python 3.8 or higher installed</li> <li>Basic familiarity with command-line interface</li> </ul>"},{"location":"getting-started/environment/#2-install-esp-idf-v43-or-higher","title":"2. Install ESP-IDF (v4.3 or higher)","text":"<p>ESP-IDF (Espressif IoT Development Framework) is the official SDK for ESP32 development.</p>"},{"location":"getting-started/environment/#installation-steps-linuxmacos","title":"Installation Steps (Linux/macOS):","text":"<pre><code>git clone --recursive https://github.com/espressif/esp-idf.git\ncd esp-idf\ngit checkout v4.3\n./install.sh\n. ./export.sh\n</code></pre> <p>To avoid re-running <code>. ./export.sh</code> every time, add it to your shell config:</p> <pre><code>echo \". $HOME/esp-idf/export.sh\" &gt;&gt; ~/.bashrc\n</code></pre> <p>Windows users should use the ESP-IDF Tools Installer</p>"},{"location":"getting-started/environment/#3-clone-the-esp32-csi-tool-repository","title":"3. Clone the ESP32-CSI Tool Repository","text":"<p>Clone the CSI-enabled firmware project:</p> <pre><code>git clone https://github.com/StevenMHernandez/ESP32-CSI-Tool.git\ncd ESP32-CSI-Tool\n</code></pre>"},{"location":"getting-started/environment/#4-choose-the-operating-mode","title":"4. Choose the Operating Mode","text":"<p>Depending on your use case, enter one of the following directories:</p> <pre><code>cd active_sta    # Active Station mode (transmitting packets)\ncd active_ap     # Active Access Point mode (collecting packets)\ncd passive       # Passive CSI capture (only listen)\n</code></pre> <p><code>passive</code> mode is often used for RX-only logging setups.</p>"},{"location":"getting-started/environment/#5-configure-the-firmware-idfpy-menuconfig","title":"5. Configure the Firmware (<code>idf.py menuconfig</code>)","text":"<p>Run the configuration menu:</p> <pre><code>idf.py menuconfig\n</code></pre>"},{"location":"getting-started/environment/#important-settings","title":"Important settings:","text":"<ul> <li>Component Config \u2192 Wi-Fi: Enable Wi-Fi CSI (Channel State Information)</li> <li>Serial flasher config: Set baud rate to at least 921600 or 1152000</li> <li>FreeRTOS: Set tick rate to 1000 Hz (under Component Config \u2192 FreeRTOS)</li> <li>Console output baud rate: Must match the flashing baud rate</li> </ul> <p>Once configured, save and exit.</p>"},{"location":"getting-started/environment/#6-build-and-flash-the-firmware","title":"6. Build and Flash the Firmware","text":"<p>Compile and upload the firmware to the ESP32:</p> <pre><code>idf.py build\nidf.py flash\n</code></pre>"},{"location":"getting-started/environment/#7-monitor-serial-output","title":"7. Monitor Serial Output","text":"<p>To monitor live CSI data:</p> <pre><code>idf.py monitor\n</code></pre> <p>If you only want CSI lines logged:</p> <pre><code>idf.py monitor | grep \"CSI_DATA\" &gt; csi_output.csv\n</code></pre> <p>To add timestamps:</p> <pre><code>idf.py monitor | python ../python_utils/serial_append_time.py &gt; csi_output_timed.csv\n</code></pre> <p>Make sure your serial port baud matches what was set in <code>menuconfig</code>.</p>"},{"location":"getting-started/environment/#8-python-environment-for-csi-scripts-optional","title":"8. Python Environment for CSI Scripts (Optional)","text":"<p>If you plan to parse or visualize CSI data:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\npip install pyserial numpy matplotlib pandas\n</code></pre> <p>Optional scripts are located in <code>python_utils/</code> inside the ESP32-CSI repo.</p>"},{"location":"getting-started/environment/#9-useful-python-scripts","title":"9. Useful Python Scripts","text":"<p>Inside <code>ESP32-CSI-Tool/python_utils/</code>:</p> Script Purpose <code>serial_plot_csi_live.py</code> Live plotting of CSI amplitude <code>serial_append_time.py</code> Add timestamps to each CSI log line <code>serial_to_dataframe.py</code> Convert CSI logs to structured pandas df"},{"location":"getting-started/environment/#10-troubleshooting-tips","title":"10. Troubleshooting Tips","text":"<ul> <li>Flashing fails at 0%: Check USB cable (must be data cable) or switch port</li> <li>No CSI output: Re-check <code>menuconfig</code> settings for CSI enable</li> <li>Garbled serial output: Baud mismatch \u2014 align <code>menuconfig</code> and terminal</li> <li>Monitor hangs: Reduce baud or check power stability</li> </ul>"},{"location":"getting-started/environment/#summary","title":"Summary","text":"<p>After following this guide, you should have:</p> <ul> <li>ESP-IDF installed and exported</li> <li>ESP32-CSI Tool firmware cloned and configured</li> <li>ESP32 board flashed and logging CSI data</li> <li>(Optional) Python environment set up for live visualization</li> </ul> <p>You\u2019re now ready to move on to data collection and analysis.</p>"},{"location":"getting-started/hardware/","title":"Hardware Requirements","text":"<p>This section provides a comprehensive list of the hardware components required to set up and run the ESP32-CSI Tool. The setup described here has been validated by the embedded team at Rayiot Solutions Inc. and ensures stable CSI data capture under various test conditions.</p>"},{"location":"getting-started/hardware/#1-esp32-development-board","title":"1. ESP32 Development Board","text":"<p>We use the ESP32-WROOM-32 DevKit v1 for all CSI-related experiments. The firmware provided by the ESP32-CSI Tool is compatible with this board, and it provides UART connectivity for reliable data transmission to the host PC.</p>"},{"location":"getting-started/hardware/#specifications","title":"Specifications:","text":"<ul> <li>Microcontroller: Tensilica Xtensa LX6 (dual-core, 240 MHz)</li> <li>Flash: 4 MB</li> <li>RAM: 520 KB SRAM</li> <li>Wi-Fi: IEEE 802.11 b/g/n</li> <li>UART, SPI, I2C, ADC interfaces</li> <li>USB-to-UART bridge onboard (CP2102 or CH340)</li> </ul>"},{"location":"getting-started/hardware/#esp32-devkit-v1","title":"ESP32 DevKit v1:","text":""},{"location":"getting-started/hardware/#notes","title":"Notes:","text":"<ul> <li>Ensure the board is genuine or from a trusted vendor to avoid UART instability.</li> <li>Boards with CP2102 USB chips tend to offer better serial stability.</li> </ul>"},{"location":"getting-started/hardware/#2-usb-cable-micro-usb","title":"2. USB Cable (Micro-USB)","text":"<p>A standard USB-A to Micro-USB cable is used to connect the ESP32 board to the host system. This serves both as a power supply and UART communication interface.</p>"},{"location":"getting-started/hardware/#notes_1","title":"Notes:","text":"<ul> <li>Use a data-capable cable (not just a charging cable).</li> <li>Cable length should be limited to under 1.5 meters for stability.</li> </ul>"},{"location":"getting-started/hardware/#image","title":"Image:","text":""},{"location":"getting-started/hardware/#3-host-machine-laptop-or-pc","title":"3. Host Machine (Laptop or PC)","text":"<p>The host machine is used for: - Flashing firmware - Monitoring UART output - Parsing and storing CSI data</p>"},{"location":"getting-started/hardware/#minimum-requirements","title":"Minimum Requirements:","text":"<ul> <li>OS: Windows 10, Linux (Ubuntu 20.04+ recommended), or macOS</li> <li>RAM: 4 GB or more</li> <li>Python 3.8+</li> <li>At least 1 free USB port</li> </ul>"},{"location":"getting-started/hardware/#4-wi-fi-router-or-access-point","title":"4. Wi-Fi Router or Access Point","text":"<p>An 802.11 b/g/n compatible router is required to generate Wi-Fi traffic for CSI collection. The ESP32 listens to these packets in monitor mode.</p>"},{"location":"getting-started/hardware/#guidelines","title":"Guidelines:","text":"<ul> <li>2.4 GHz only (ESP32 does not support 5 GHz)</li> <li>Place ESP32 boards within 2\u20134 meters of the access point during experiments</li> <li>Ensure the network is lightly loaded to avoid interference</li> </ul>"},{"location":"getting-started/hardware/#image_1","title":"Image:","text":""},{"location":"getting-started/hardware/#5-power-supply-optional","title":"5. Power Supply (Optional)","text":"<p>If the USB port is not used for power, or if conducting mobile experiments (e.g., from a battery):</p>"},{"location":"getting-started/hardware/#recommended","title":"Recommended:","text":"<ul> <li>5V, 2A portable power bank</li> <li>USB breakout board with external power supply</li> <li>Li-ion battery with voltage regulator (for compact embedded systems)</li> </ul>"},{"location":"getting-started/hardware/#image_2","title":"Image:","text":""},{"location":"getting-started/hardware/#6-physical-mounts-and-fixtures","title":"6. Physical Mounts and Fixtures","text":"<p>To ensure reproducibility and reduce signal artifacts caused by board movement:</p>"},{"location":"getting-started/hardware/#used","title":"Used:","text":"<ul> <li>Tripod stands or custom 3D-printed holders</li> <li>Double-sided tape or rubber pads for fixed placement</li> <li>Ruler/tape measure for documenting layout distance between devices</li> </ul>"},{"location":"getting-started/hardware/#image_3","title":"Image:","text":""},{"location":"getting-started/hardware/#7-optional-accessories","title":"7. Optional Accessories","text":"Item Purpose External Antennas For improved signal strength and directionality Heat sinks Prevent overheating during long test sessions Breadboards For clean prototyping in multipoint sensing setups EMI shields For signal isolation in noisy environments"},{"location":"getting-started/hardware/#8-hardware-procurement-checklist","title":"8. Hardware Procurement Checklist","text":"<p>Below is the recommended list of hardware components needed for setting up the ESP32-CSI Tool environment. This list can be used for procurement, budgeting, or internal tracking.</p> Item Quantity Specification / Model Preferred Vendor Approx. Cost (INR) Notes ESP32 DevKit v1 2 ESP32-WROOM-32, CP2102/CH340 Mouser, Robu.in 350 \u2013 500 Minimum 2 units for TX/RX USB-A to Micro-USB 2 Data-capable, &lt;1.5 m length Amazon, local electronics 50 \u2013 100 Must support power + UART Wi-Fi Router 1 2.4 GHz, 802.11 b/g/n TP-Link, D-Link 1000 \u2013 1500 Basic router sufficient Power Bank 1 5V / 2A, 5000\u201310000 mAh Mi, Realme, Ambrane 600 \u2013 1200 Optional \u2013 for mobile tests Tripod/Stand 2 Adjustable / table mount Amazon 300 \u2013 500 For stable sensor placement External Antenna Optional SMA Antenna (if board supports) Robu.in, AliExpress 200 \u2013 400 Needed for WROVER or IPEX Breadboard Optional Full-size or mini Local electronics 100 Useful for compact setup Heat Sinks Optional Adhesive copper/aluminum Amazon, Robu.in 100 \u2013 200 For long-duration testing <p>Download as CSV: Hardware Procurement Checklist (CSV)</p>"},{"location":"getting-started/hardware/#summary","title":"Summary","text":"<p>The hardware listed above is sufficient to fully deploy and evaluate the ESP32-CSI Tool in a variety of environments \u2014 ranging from lab setups to field trials. Proper handling an</p>"},{"location":"getting-started/software/","title":"Software Requirements","text":"<p>This section outlines the software tools, environments, and dependencies required to work with the ESP32-CSI Tool. These tools enable firmware development, serial data capture, preprocessing, and initial visualization.</p>"},{"location":"getting-started/software/#1-operating-system","title":"1. Operating System","text":"<p>The ESP32-CSI Tool can run on all major desktop operating systems:</p> OS Status Recommended Version Windows \u2705 Supported Windows 10 or 11 Linux \u2705 Preferred Ubuntu 20.04+ or Debian 11 macOS \u2705 Supported macOS 12+ <p>For development purposes, Linux (Ubuntu) is preferred due to seamless ESP-IDF compatibility and serial tool support.</p>"},{"location":"getting-started/software/#2-esp-idf-espressif-iot-development-framework","title":"2. ESP-IDF (Espressif IoT Development Framework)","text":"<p>ESP-IDF is the official development environment for ESP32. It is required for building and flashing the custom CSI-enabled firmware.</p> <p>\ud83d\udd17 For detailed setup instructions, see Setting Up the Environment.</p> <p>Minimum required version: <code>v4.3</code></p>"},{"location":"getting-started/software/#3-python-environment","title":"3. Python Environment","text":"<p>You will need Python 3.8 or higher installed on your machine to run CSI logging and visualization scripts.</p> <p>Recommended libraries: - <code>pyserial</code>: For reading CSI data via UART - <code>numpy</code>, <code>pandas</code>: For processing data arrays and tabular data - <code>matplotlib</code>: For plotting CSI amplitude and phase</p> <p>Install them using:</p> <pre><code>pip install pyserial numpy matplotlib pandas\n</code></pre> <p>\ud83d\udd17 For virtual environment setup and best practices, refer to Setting Up the Environment.</p>"},{"location":"getting-started/software/#4-serial-monitoring-tools","title":"4. Serial Monitoring Tools","text":"<p>You can use any of the following tools to monitor CSI data over serial:</p> Tool Platform Notes <code>idf.py monitor</code> All (in ESP-IDF) Built-in monitor, recommended <code>minicom</code> Linux Terminal-based, lightweight <code>PuTTY</code> Windows GUI-based, widely used <code>screen</code> macOS/Linux Terminal-based serial monitor"},{"location":"getting-started/software/#5-git-version-control","title":"5. Git &amp; Version Control","text":"<p>Git is essential for cloning the ESP32-CSI Tool repository and versioning your changes.</p> <p>Basic commands:</p> <pre><code>git clone https://github.com/StevenMHernandez/ESP32-CSI-Tool.git\ncd ESP32-CSI-Tool\n</code></pre> <p>\ud83d\udd17 Refer to Setting Up the Environment for project mode selection and build configuration.</p>"},{"location":"getting-started/software/#references","title":"References","text":"<p>Much of the ESP-IDF setup and configuration guidance in this document is based on:</p> <ul> <li>Steven M. Hernandez, ESP32-CSI Tool Documentation, GitHub Pages, MIT Licensed.</li> </ul> <p>Portions of this documentation are adapted from the ESP32-CSI Tool by Steven M. Hernandez, which is licensed under the MIT License.</p>"},{"location":"getting-started/software/#summary","title":"Summary","text":"<p>To run and extend the ESP32-CSI Tool successfully, the following software stack is required:</p> <ul> <li>A compatible operating system (Ubuntu recommended)</li> <li>ESP-IDF v4.3+ (see environment setup)</li> <li>Python 3.8+ with required libraries</li> <li>Serial monitor tools (CLI or GUI)</li> <li>Git for cloning and version control</li> </ul> <p>Once these tools are installed, follow Setting Up the Environment to flash the firmware and begin CSI data collection.</p>"},{"location":"introduction/goals/","title":"Goals of the Project Using CSI","text":"<p>At Rayiot Solutions Inc., one of our key initiatives is to develop a contactless, non-invasive system capable of estimating human breathing rates using Wi-Fi signal variations. Channel State Information (CSI), extracted from the ESP32 Wi-Fi chipset, serves as the foundational signal input for this system.</p> <p>The primary focus of the embedded systems team is to establish a robust CSI acquisition pipeline, preprocess the data in a meaningful format, and provide a clean, high-resolution signal to downstream DSP and AI modules. This section outlines the goals and deliverables of the embedded team in this context.</p>"},{"location":"introduction/goals/#1-to-collect-high-quality-csi-data","title":"1. To Collect High-Quality CSI Data","text":"<p>The first and foremost goal is to set up an environment that consistently produces clean and stable CSI data under various conditions. This involves:</p> <ul> <li>Selecting and configuring suitable ESP32 hardware modules</li> <li>Flashing the CSI-enabled firmware with optimized UART and sampling parameters</li> <li>Ensuring proper placement and orientation of TX and RX devices</li> <li>Isolating environmental noise as much as possible</li> <li>Logging CSI packets with minimal packet loss or corruption</li> </ul> <p>The collected CSI should cover diverse scenarios, including static, single-subject breathing conditions in quiet environments.</p>"},{"location":"introduction/goals/#2-to-extract-and-format-key-signal-components","title":"2. To Extract and Format Key Signal Components","text":"<p>After CSI data is captured over UART, it is processed to extract the following critical signal components:</p> <ul> <li>Timestamps: To correlate CSI samples and track changes over time</li> <li>Amplitude values: Calculated from the real and imaginary components per   subcarrier, used to observe periodic variations from breathing</li> <li>Phase values: Cleaned and unwrapped to analyze finer signal characteristics</li> <li>RSSI (Received Signal Strength Indicator): Used as an auxiliary reference   metric for signal quality</li> </ul> <p>The processed output is structured in a consistent format (CSV/JSON) with each entry timestamped and annotated for analysis.</p>"},{"location":"introduction/goals/#3-to-implement-lightweight-preprocessing","title":"3. To Implement Lightweight Preprocessing","text":"<p>The embedded team currently focuses on essential phase preprocessing techniques to ensure that the raw CSI data is usable for downstream signal analysis.</p> <p>The following operations are implemented:</p> <ul> <li>Phase sanitization: Filtering out invalid or unstable phase values caused by   noise or hardware-induced anomalies.</li> <li>Phase unwrapping: Correcting discontinuities in the raw phase values that   result from wrapping around the [-\u03c0, \u03c0] range.</li> <li>Linear fitting: Applying linear regression to the phase across subcarriers to   remove linear trends (caused by hardware delays), isolating meaningful variations.</li> </ul> <p>These preprocessing steps are lightweight, non-computationally intensive, and performed in real-time or near-real-time as part of the UART CSI data parsing pipeline.</p> <p>At this stage, no amplitude filtering, outlier removal, or subcarrier averaging is performed. The focus remains on producing clean, unwrapped, and detrended phase data to support accurate frequency-domain analysis by the DSP team.</p>"},{"location":"introduction/goals/#4-to-package-and-hand-off-data-for-dsp-and-ai-pipelines","title":"4. To Package and Hand-Off Data for DSP and AI Pipelines","text":"<p>Once data is collected and processed, it is passed to the downstream teams:</p> <ul> <li>DSP Team: Applies frequency-domain analysis, bandpass filtering, and signal   isolation to extract the breathing envelope</li> <li>AI Team: Uses preprocessed data to train and evaluate models that estimate   breathing rate under various conditions</li> </ul> <p>To support this, the embedded team ensures:</p> <ul> <li>The file formats and directory structure are standardized</li> <li>Metadata (e.g., sampling rate, test ID, subject info) is included</li> <li>Data integrity is verified and logged before upload or transfer</li> </ul>"},{"location":"introduction/goals/#5-to-iterate-and-improve-data-fidelity","title":"5. To Iterate and Improve Data Fidelity","text":"<p>As part of an iterative process, the team constantly reviews the following:</p> <ul> <li>Packet capture success rate</li> <li>Signal-to-noise ratio of the extracted features</li> <li>Alignment of signal features with expected physiological behavior</li> </ul> <p>Feedback from DSP and AI teams is looped back to improve ESP32 configuration, hardware layout, and firmware tuning.</p>"},{"location":"introduction/goals/#summary","title":"Summary","text":"<p>The goal of this CSI-based project at Rayiot Solutions Inc. is not only to collect raw wireless data but to turn it into a reliable, signal-rich source that can power intelligent sensing applications. The embedded team plays a critical role in laying the groundwork by building a stable, configurable, and reproducible CSI pipeline optimized for breathing rate estimation and future expansion into other health and behavioral sensing tasks.</p>"},{"location":"introduction/overview/","title":"Overview of the ESP32-CSI Tool","text":"<p>The ESP32-CSI Tool is an open source project developed to extract Channel State Information (CSI) from Wi-Fi packets received by ESP32-based devices. CSI provides detailed insights into how a wireless signal travels from a transmitter to a receiver. It captures phenomena such as reflection, scattering, fading, and attenuation across individual subcarriers of the Wi-Fi channel. Compared to traditional metrics like RSSI (Received Signal Strength Indicator), CSI offers a much more granular view of the wireless environment.</p> <p>The ESP32 is a low-cost, dual-core microcontroller developed by Espressif Systems, featuring integrated Wi-Fi and Bluetooth capabilities. Its affordability, low power consumption, and programmability make it a suitable platform for wireless sensing applications. The ESP32-CSI Tool leverages low-level access to the Wi-Fi driver, enabling the collection of CSI data that is typically not exposed to the application layer.</p> <p>The primary goal of the ESP32-CSI Tool is to facilitate real-time CSI data collection from Wi-Fi frames. This is achieved by:</p> <ul> <li>Enabling monitor mode on the ESP32  </li> <li>Filtering frames by MAC address or type  </li> <li>Setting fixed data rates  </li> <li>Extracting CSI values for each received frame  </li> </ul> <p>The collected data is transmitted via the serial interface (UART), where it can be captured, logged, and analyzed using external tools. The tool supports output formats such as CSV and PCAP, making it compatible with popular tools like Wireshark or Python-based data analysis libraries.</p> <p>This capability enables a wide range of applications, such as:</p> <ul> <li>Breathing rate estimation</li> <li>Indoor localization and presence detection  </li> <li>Gesture recognition without cameras  </li> <li>Human activity monitoring for smart environments  </li> <li>Research in wireless signal processing and machine learning  </li> </ul> <p>The tool has gained popularity among researchers, engineers, and hobbyists due to its:</p> <ul> <li>Open-source nature  </li> <li>Minimal hardware requirements (just ESP32 and a computer)  </li> <li>Ease of use and extensibility  </li> </ul> <p>The ESP32-CSI Tool was originally developed by Steven M. Hernandez and is actively maintained on GitHub. The project is continually evolving with contributions from a global community applying it in various domains, including human-computer interaction, biomedical sensing, and intelligent monitoring systems.</p> <p>This documentation provides a comprehensive guide to working with the ESP32-CSI Tool. It includes:</p> <ul> <li>Hardware and software setup instructions  </li> <li>Step-by-step usage guide  </li> <li>CSI data visualization and interpretation techniques  </li> <li>Challenges and limitations encountered during implementation  </li> <li>Potential improvements and future directions  </li> </ul> <p>The content is enriched with real setup images, sample output screenshots, graphs, screen recordings, and code examples to support a deeper understanding of the tool\u2019s functionality and its applications.</p>"},{"location":"introduction/purpose/","title":"Purpose of This Documentation","text":"<p>At Rayiot Solutions Inc., our embedded systems team has undertaken a series of initiatives centered around using Wi-Fi-based sensing technologies to enable non-invasive human monitoring, gesture recognition, and indoor localization. A key enabler of these capabilities is the ESP32-CSI Tool \u2014 an open-source utility that allows us to extract Channel State Information (CSI) from ESP32-based devices.</p> <p>This documentation has been created to formalize our internal work, streamline collaboration across teams, and serve as a long-term technical reference for projects involving CSI-based sensing.</p>"},{"location":"introduction/purpose/#objectives-of-this-documentation","title":"Objectives of This Documentation","text":""},{"location":"introduction/purpose/#1-to-establish-technical-clarity-and-knowledge-sharing","title":"1. To Establish Technical Clarity and Knowledge Sharing","text":"<p>Our embedded team has invested time in understanding the operational nuances of the ESP32-CSI Tool \u2014 from environment setup, firmware modification, and UART-based data capture, to real-time processing and visualization of CSI data. This documentation is intended to consolidate that knowledge and make it accessible for onboarding new engineers, collaborating with AI and data teams, and supporting system-level integration with our cloud and mobile platforms.</p>"},{"location":"introduction/purpose/#2-to-standardize-setup-and-experimentation","title":"2. To Standardize Setup and Experimentation","text":"<p>Different engineers working on different modules of the Rayiot sensing pipeline need a consistent and reliable CSI data collection and visualization setup. This documentation provides a reproducible process \u2014 including hardware wiring, flashing instructions, configuration steps, and supporting scripts \u2014 to ensure alignment across devices, locations, and development teams.</p>"},{"location":"introduction/purpose/#3-to-support-application-prototyping-and-feature-evaluation","title":"3. To Support Application Prototyping and Feature Evaluation","text":"<p>Our use of CSI is directly aligned with our product goals in smart health, behavioral sensing, and contactless monitoring. By documenting various experiments such as presence detection, fall detection, and motion classification, we aim to accelerate the prototyping of features that can be incorporated into our Raybaby platform or future product lines.</p>"},{"location":"introduction/purpose/#4-to-identify-limitations-and-engineering-risks-early","title":"4. To Identify Limitations and Engineering Risks Early","text":"<p>The CSI pipeline introduces several engineering challenges: real-time data stability, signal quality under environmental noise, variability between ESP32 modules, and data synchronization across multiple sensing nodes. This documentation serves as a log of technical blockers, firmware anomalies, and configuration constraints observed during our evaluation, along with any workarounds or recommendations.</p>"},{"location":"introduction/purpose/#5-to-align-embedded-ai-and-dsp-teams","title":"5. To Align Embedded, AI, and DSP Teams","text":"<p>Our CSI-based sensing work does not end at raw data collection. The captured data is analyzed, filtered, and used to train AI models \u2014 which in turn must integrate with mobile or cloud platforms. By making this documentation the single source of truth, we ensure all teams \u2014 embedded, AI, cloud, and app development \u2014 have access to the assumptions, parameters, and data interpretation practices used at each stage.</p>"},{"location":"introduction/purpose/#scope-of-the-documentation","title":"Scope of the Documentation","text":"<p>This documentation includes:</p> <ul> <li>Overview of CSI and its relevance to Rayiot use cases</li> <li>Setup instructions for the ESP32-CSI Tool and supporting environment</li> <li>Standard operating procedures for data collection</li> <li>Data formats and example outputs</li> <li>Common signal patterns for test scenarios (e.g., human movement, gestures)</li> <li>Challenges faced during firmware development and hardware calibration</li> <li>Sample visualizations and interpretation notes</li> <li>Guidelines for handing over data to the AI team</li> </ul>"},{"location":"introduction/purpose/#audience","title":"Audience","text":"<p>The primary audience for this documentation includes:</p> <ul> <li>Embedded developers working on firmware and device-side CSI capture</li> <li>Data scientists building models from CSI logs</li> <li>QA teams validating sensing accuracy across devices and scenarios</li> <li>Product engineers evaluating the feasibility of CSI-based features</li> <li>Interns or new hires onboarding into the Rayiot sensing pipeline</li> </ul>"},{"location":"introduction/purpose/#summary","title":"Summary","text":"<p>This documentation is part of Rayiot Solutions Inc.'s internal knowledge base for Wi-Fi sensing and CSI-enabled embedded development. It supports current and future projects by ensuring that engineering efforts are well-documented, reproducible, and aligned across teams. It reflects our broader goal of developing robust, scalable, and intelligent sensing systems using low-cost hardware like the ESP32.</p>"},{"location":"introduction/tools/","title":"Tools and Hardware Used","text":"<p>The successful execution of CSI-based sensing experiments at Rayiot Solutions Inc. relies on a carefully selected combination of embedded hardware, software tools, signal capture utilities, and data analysis frameworks. The embedded team has standardized the tools and components required to ensure consistent and reproducible data collection across different experiments and test environments.</p> <p>This section outlines the specific hardware and software infrastructure used throughout the project.</p>"},{"location":"introduction/tools/#1-hardware-components","title":"1. Hardware Components","text":""},{"location":"introduction/tools/#esp32-development-boards","title":"ESP32 Development Boards","text":"<p>We primarily use the ESP32-WROOM-32 module, which offers the following features:</p> <ul> <li>Dual-core Xtensa\u00ae 32-bit LX6 processor</li> <li>2.4 GHz Wi-Fi (802.11 b/g/n)</li> <li>UART, SPI, I2C, ADC, and GPIO interfaces</li> <li>Onboard antenna or external antenna option (depending on model)</li> </ul> <p>In some test cases, we use variants such as ESP32-DevKitC or ESP32-WROVER for flexibility in debugging and USB connectivity.</p> <p>Reason for selection: - Low cost and widespread availability - Built-in support for Wi-Fi CSI capture via modified firmware - USB support for power and serial communication</p>"},{"location":"introduction/tools/#power-supply","title":"Power Supply","text":"<ul> <li>Standard USB 5V power via data cable</li> <li>In mobile experiments, portable power banks are used to eliminate wall   interference</li> </ul>"},{"location":"introduction/tools/#cabling-and-connectors","title":"Cabling and Connectors","text":"<ul> <li>USB-A to Micro USB or USB-C depending on board variant</li> <li>Jumper wires or breadboards (used in antenna placement or multi-node testing)</li> </ul>"},{"location":"introduction/tools/#optional-accessories","title":"Optional Accessories","text":"<ul> <li>External Antennas: Used for improving signal clarity in specific scenarios</li> <li>Stands and Fixtures: To fix the ESP32 boards at predefined heights and angles</li> <li>Metal-free enclosures: To isolate reflections in controlled experiments</li> </ul>"},{"location":"introduction/tools/#2-software-tools","title":"2. Software Tools","text":""},{"location":"introduction/tools/#esp-idf-espressif-iot-development-framework","title":"ESP-IDF (Espressif IoT Development Framework)","text":"<ul> <li>Used to build and flash custom CSI-enabled firmware onto ESP32</li> <li>Version 4.2 or higher is required for CSI support</li> </ul> <p>Key Commands Used: - <code>idf.py build</code> - <code>idf.py flash</code> - <code>idf.py monitor</code></p>"},{"location":"introduction/tools/#python-38","title":"Python 3.8+","text":"<p>Used extensively for: - Serial data parsing - Phase unwrapping and linear fitting - Saving data to CSV - Plotting amplitude and phase (optional)</p> <p>Essential Libraries: - <code>pyserial</code>: Reading data from UART - <code>numpy</code>, <code>scipy</code>: Signal processing - <code>matplotlib</code>: Plotting - <code>pandas</code>: Data manipulation</p>"},{"location":"introduction/tools/#serial-monitors","title":"Serial Monitors","text":"<p>For quick inspection and debugging of raw UART output: - <code>minicom</code> (Linux) - <code>PuTTY</code> (Windows) - <code>screen</code> or <code>idf.py monitor</code> (cross-platform)</p>"},{"location":"introduction/tools/#git-and-version-control","title":"Git and Version Control","text":"<p>All firmware builds, test configurations, and scripts are version-controlled using Git, ensuring reproducibility and traceability.</p> <ul> <li>GitHub is used for codebase storage</li> <li>Internal wiki and Git issues track build results, bugs, and release notes</li> </ul>"},{"location":"introduction/tools/#3-data-analysis-visualization","title":"3. Data Analysis &amp; Visualization","text":"<p>Although preprocessing is minimal on the embedded side, initial exploratory analysis is performed using the following tools:</p> <ul> <li>Jupyter Notebooks for interactive data exploration</li> <li>CSV file viewers for raw inspection</li> <li>Custom scripts for plotting unwrapped phase vs time</li> <li>Wireshark (for PCAP-based analysis when applicable)</li> </ul>"},{"location":"introduction/tools/#4-documentation-and-collaboration-tools","title":"4. Documentation and Collaboration Tools","text":"<p>To document and share findings internally and with adjacent teams: - MKDocs with Material Theme for structured documentation - Google Drive / Shared Folders for image and dataset storage - Notion / Internal wiki for notes and experiment tracking - Slack / Microsoft Teams for updates and coordination across embedded, DSP,   and AI teams</p>"},{"location":"introduction/tools/#summary","title":"Summary","text":"<p>The combination of reliable ESP32 hardware, open-source development tools, and internally developed data handling scripts enables the embedded team at Rayiot Solutions Inc. to operate a consistent CSI collection pipeline. This tooling infrastructure forms the foundation for downstream tasks like signal processing, model training, and system validation for breathing rate estimation and related use cases.</p>"},{"location":"optimization/optimizations/","title":"Optimization &amp; Improvements","text":"<p>During the development and experimentation with CSI-based sensing, several optimization strategies were introduced to enhance data quality, signal consistency, and processing efficiency. These improvements targeted both firmware behavior and host-side processing.</p>"},{"location":"optimization/optimizations/#1-uart-and-serial-logging-optimization","title":"1. UART and Serial Logging Optimization","text":""},{"location":"optimization/optimizations/#problem","title":"Problem","text":"<ul> <li>Dropped packets and serial corruption at lower baud rates</li> </ul>"},{"location":"optimization/optimizations/#solution","title":"Solution","text":"<ul> <li>Increased UART baud rate to 921600 or 1152000</li> <li>Filtered CSI logs to remove non-essential output</li> <li>Used timestamped logging to structure CSI entries on host side</li> </ul>"},{"location":"optimization/optimizations/#2-phase-preprocessing-enhancements","title":"2. Phase Preprocessing Enhancements","text":""},{"location":"optimization/optimizations/#problem_1","title":"Problem","text":"<ul> <li>Wrapped and noisy phase values reduced signal reliability</li> </ul>"},{"location":"optimization/optimizations/#solution_1","title":"Solution","text":"<ul> <li>Developed custom unwrapping and linear detrending logic (inspired by phase_wrapped_filter_linear_fitting.py)</li> <li>Preprocessing reduced hardware bias and restored continuity across frames</li> <li>Applied normalization to amplitude and detrended phase before ML pipelines</li> </ul>"},{"location":"optimization/optimizations/#3-subcarrier-selection-strategy","title":"3. Subcarrier Selection Strategy","text":""},{"location":"optimization/optimizations/#problem_2","title":"Problem","text":"<ul> <li>Inconsistent signal quality across subcarriers</li> </ul>"},{"location":"optimization/optimizations/#solution_2","title":"Solution","text":"<ul> <li>Performed statistical variance analysis to identify stable subcarriers</li> <li>Excluded edge subcarriers and those with high-frequency noise</li> <li>Focused on ~20\u201330 central subcarriers for respiration and presence tasks</li> </ul>"},{"location":"optimization/optimizations/#4-tooling-and-data-handling","title":"4. Tooling and Data Handling","text":""},{"location":"optimization/optimizations/#improvements","title":"Improvements","text":"<ul> <li>Created custom CSV parsers to clean malformed CSI logs</li> <li>Used Pandas and Numpy for rapid batch preprocessing</li> <li>Enabled live plots using Matplotlib for in-session tuning</li> </ul>"},{"location":"optimization/optimizations/#5-experiment-repeatability","title":"5. Experiment Repeatability","text":""},{"location":"optimization/optimizations/#steps-taken","title":"Steps Taken","text":"<ul> <li>Documented environment conditions, TX/RX positions, and signal settings</li> <li>Used fixed mounting tripods and printed floor markers</li> <li>Replayed data logs for consistent benchmarking</li> </ul>"},{"location":"optimization/optimizations/#summary","title":"Summary","text":"<p>These optimization techniques helped make CSI sensing more robust, consistent, and portable across different environments. From UART tuning to smarter subcarrier filtering and dynamic thresholds, each step contributed to cleaner signals and improved real-world usability.</p>"},{"location":"references/references/","title":"References","text":"<p>Below is a list of key resources, research papers, tools, and repositories referenced during the development and documentation of this project.</p>"},{"location":"references/references/#1-primary-tools-and-documentation","title":"1. Primary Tools and Documentation","text":"<ul> <li> <p>ESP32-CSI Tool by Steven M. Hernandez   https://stevenmhernandez.github.io/ESP32-CSI-Tool/   GitHub Repository: https://github.com/StevenMHernandez/ESP32-CSI-Tool</p> </li> <li> <p>ESP-IDF (Espressif IoT Development Framework)   https://docs.espressif.com/projects/esp-idf/en/latest/esp32/</p> </li> <li> <p>Arduino Core for ESP32   https://github.com/espressif/arduino-esp32</p> </li> </ul>"},{"location":"references/references/#2-python-libraries-used","title":"2. Python Libraries Used","text":"<ul> <li>Numpy: https://numpy.org/</li> <li>Matplotlib: https://matplotlib.org/</li> <li>Pandas: https://pandas.pydata.org/</li> <li>Scipy: https://scipy.org/</li> <li>Scikit-learn: https://scikit-learn.org/</li> </ul>"},{"location":"references/references/#3-research-papers-and-academic-resources","title":"3. Research Papers and Academic Resources","text":"<ul> <li>Y. Wang et al., \"CSI-based Human Activity Recognition: A Survey,\" ACM Computing Surveys, 2021.</li> <li>F. Adib et al., \"Smart Homes That Monitor Breathing and Heart Rate,\" CHI 2015.</li> <li>J. Wang et al., \"E-eyes: Device-Free Location-Oriented Activity Identification Using Fine-Grained WiFi Signatures,\" MobiCom 2014.</li> </ul>"},{"location":"references/references/#4-scripts-and-utilities","title":"4. Scripts and Utilities","text":"<ul> <li><code>serial_plot_csi_live.py</code>, <code>serial_to_dataframe.py</code>, <code>serial_append_time.py</code> \u2014 provided within ESP32-CSI Tool repo</li> <li>Custom preprocessing scripts written for phase unwrapping and linear detrending</li> </ul>"},{"location":"references/references/#5-images-and-visuals","title":"5. Images and Visuals","text":"<ul> <li>All screenshots, plots, and experimental setup photos were captured during in-house testing by the RayIoT Solutions embedded team.</li> </ul>"},{"location":"references/references/#summary","title":"Summary","text":"<p>These references supported both the practical implementation and theoretical foundation for CSI-based sensing using ESP32 devices.</p>"}]}